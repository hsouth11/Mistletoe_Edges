---
title: "Site Level Analyses"
author: "Hanno Southam"
date: "`r Sys.Date()`"
output: html_document
---
UPDATED: 13 Feb 2025
##############
READ ME
This script compares the 11 HDM study sites to eachother. 

Section 1 compares the different site climates, using data from Climate BC 
(https://climatebc.ca/mapVersion) and Barrett et al. (2012) as a framework for 
selecting and interpreting variables. There is a focus on precipitation 
because the Pacific Highway sites (wettest) have relatively low rates of 
infection. 

Section 2 compares the size and composition of trees in the regen and mature 
components between sites. 

Section 3 compares HDM infection in the mature component between sites to get a 
high-level understanding if the infection sources are similar between sites. 

Section 4 compares HDM infection in the regen component between sites. 

Summary tables and figures are created in each section for writing and 
downstream analyses. The primary starting object for the script is the output
of the 'seed load.Rmd' script (trees_sl.csv). 

References
Barrett, T. M., Latta, G., Hennon, P. E., Eskelson, B. N. I., & Temesgen, H. (2012). Host–parasite distributions under changing climate: Tsuga heterophylla and Arceuthobium tsugense in Alaska. Canadian Journal of Forest Research, 42(4), 642–656. https://doi.org/10.1139/x2012-016
##############

#Load packages
```{r}
library(tidyverse)
library(here)
library(RColorBrewer)
library(ggrepel)
library(ggpubr)
```

#Prep
##Load and format data
Read in and format the various datasets from the HDM sites
```{r}
rm(list=ls(all=TRUE))

##Dataset 1: site data. 
#This contains variables at the site level. The key pieces for analysis are: 
#year harvested and CWH subzone
site <- read_csv(here("data/cleaned/site_data.csv"))
str(site)
summary(site)

#Order by site_id, used to seeing it in this order
site <- arrange(site, site_id)

#Create some variables to use in summary tables and figures
#Convert date_surveyed to date format
site <- site %>% rename(date_sur_char = date_surveyed) %>% 
  mutate(date_sur = dmy(date_sur_char)) %>% 
  relocate(date_sur, .after = date_sur_char)

#Extract year
site <- site %>% mutate(yr_sur = year(date_sur))
#Recalculate age column
site <- site %>% mutate(age = yr_sur - yr_har)
site$age #luckily, got pretty good spread

#Create a single variable from all the pieces of a BEC zone
site <- site %>% 
  unite(col = bec, sep = "", c("bec_z", "bec_sz", "bec_var"), remove = FALSE)

#Create a variable that combines site_id, bec, and regen age 
site <- site %>% unite(col = id_bec_age_f, sep = ", ", 
                       c("site_id", "bec", "age"), 
                       remove = FALSE) %>% 
  mutate(id_bec_age_f = factor(id_bec_age_f)) %>% 
  relocate(id_bec_age_f, .after = site_id)

#Make cluster, bec and id_bec_age_f factors
site <- site %>% mutate(across(c(cluster, bec, id_bec_age_f), ~as.factor(.)))
str(site)


#Dataset 2: transect data
#This describes the transects extending from the edge line into the regen
#component. There are three transects per site. Within a site, all transects
#are intended to be the same length; there were a couple exceptions (due to
#incorrect layout and one transect being extended to traverse a blowdown 
#patch). The length measured across all variables within a site is recorded 
#in the tr_leng_s variable. 
tran <- read_csv(here("./data/cleaned/transect_data_c.csv"))
head(tran)
str(tran)


##Dataset 3: tree data
#This contains data for each measured tree (mature and regen trees)
#Using trees_sl object, which is the last trees object in the workflow
#Treats assessed_by var as a logical for some reason and throws up an error. 
#Not a problem and not going to use this var
trees <- read_csv("data/workflow/trees_sl.csv")
str(trees)
summary(trees)

#Convert factor vars to factors: 
trees <- trees %>% mutate(across(
  c(site_id, spp, status, hdm_pa, b_lc, 
    broom_pa, broom_pos, stem_pa, crown_class, crown_cond, outside_10, assessed_by, tree_type, dmr_f),
  ~as.factor(.)))

#Convert plot_id and dmrs to integers
trees <- trees %>% mutate(across(
  c(plot_id, dmr_l, dmr_m, dmr_u, dmr), ~as.integer(.)))

str(trees)

#Create new factor dmr variable that has fewer levels and ascends logically from healthy to most infected
levels(trees$dmr_f)
trees <- trees %>% 
  mutate(dmr_f2 = case_when((dmr_f =="1" | dmr_f=="2") ~ "1-2", 
                            (dmr_f =="3" | dmr_f=="4") ~ "3-4", 
                            (dmr_f =="5" | dmr_f=="6") ~ "5-6", 
                            .default = dmr_f))
trees <- trees %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("-", "DU", "0","IBLC", 
                                            "1-2", "3-4", "5-6", "DI")))
summary(trees$dmr_f2)

#Create new spp variable that sets all spp that aren't major species to "other"
maj_spp <- c("Hw", "Cw", "Fd", "Ba")
trees <- trees %>% 
  mutate(spp2 = if_else(spp %in% maj_spp, spp, "other")) %>% 
  mutate(spp2 = factor(spp2, levels = c("Hw", "Ba", "Cw", "Fd", "other")))

#Join some site level variables to tree data: 
trees <- left_join(trees, select(site, cluster, bec, 
                                 id_bec_age_f, age, site_id), by="site_id")

#Join identical transect length measured at each site to tree data
trees <- left_join(trees, select(tran, transect_id, tr_leng_s),
                   by = join_by("plot_id" == "transect_id"))
```

##Subset data to objects for different comparisons
There are a couple things we need to consider to ensure we are making fair 
comparisons throughout this script: 
(1) At a few sites we mapped mature trees up to 15m from the edge, when the 
standard was 10m.
(2) Regen transects are variable lengths (but constant within a site, with two
exceptions).  
(3) At two sites (mi_1) and (mk_3) the transect length within a site varied.

We want to make sure that whenever we are comparing two sites, we are comparing
trees from equivalent areas. 

Deal with the first of these right off the bat by removing mature trees >10m 
from the edge. 
```{r}
trees <- trees %>% filter(outside_10 =="N" | is.na(outside_10))
```

Calculate basal area (m^2) from dbhg. We will use this throughout the rest of 
the script
https://en.wikipedia.org/wiki/Basal_area
```{r}
trees <- trees %>% mutate(ba_m2 = pi*((dbh/100)/2)^2)
```

Break apart the dataset into different components. At the highest level, 
separate mature and regen components. Then within regen components, separate
out a dataset of trees <=15m from the edge and one of trees <=50m from the edge.

The minimum transect length was 15m, so all sites have data for 0-15m; this 
subset will be used to compare size an composition across sites and also for
HDM infection summaries within the zone of influence of the mature component. 
The dataset from 0-50m will include simulated trees to a different extent for
different sites; it will be used to provide HDM infection summaries over a 
larger range. 

A binned version of dbh is also created here for plotting to avoid creating it
multiple times when the objects are split apart. 
```{r}
#Subdivide data into mature and regen components
mature <- trees %>% filter(tree_type=="mature") 
regen <- trees %>% filter(tree_type == "regen") 

#Create bins of diameter classes from dbh
##Default is for intervals to be half-open. They include the upper bound but not the lower bound. e.g. (10,20] includes 20 but (20, 30] does not
## https://stackoverflow.com/questions/41304960/how-to-create-breaks-using-the-cut-function-without-numbers-overlapping
#Create a smaller bin for regen trees and a larger one for mature trees 
range(mature$dbh)
mature <- mature %>% 
  mutate(dbh_bin2 = cut(dbh, breaks = c(9, 15, 25, 35, 45, 55, 65, 75, 85,
                                       95, 105, 115, 125, 135, 145, 155,
                                       165, 175, 185, 195, 205, 300),
                       include.lowest = TRUE))

range(regen$dbh)
regen <- regen %>% 
  mutate(dbh_bin = cut(dbh, breaks = c(4, 10, 15, 20, 25, 30, 35, 40, 45,
                                       50, 55, 60, 65, 70, 75, 80,
                                       85, 90, 95, 100, 105, 110, 115, 120,
                                       125, 130, 135, 140, 145, 150, 155, 
                                       160, 165, 170, 175, 180, 185, 190, 
                                       195, 200, 300),
                       include.lowest = TRUE))

#Split regen object into datasets of <=15m and <=50m from edge
regen_15 <- regen %>% filter(dist_y_h <= 15)
regen_50 <- regen %>% filter(dist_y_h <= 50)
```

Create a conversion factor to represent trees on a per hectare basis. The 
comparisons in this script are at the site level, so this factor should 
represent each tree's contribution to the total area surveyed at a site; for 
mature trees, this is simple because there were no subunits but for regen trees
we need to pool the three transects. 
- Mature component footprint = 55x10m =550m2=0.055ha
- Regen transect footprint = # transects* transect length (15 or 50m) x 
5m = xx m2 = xx ha

Also add columns with basal area on a per hectare basis. Use this frequently.
```{r}
mature <- mature %>% mutate(phf_site = 1/(55*10/10000)) %>% 
  mutate(ba_m2_ph = ba_m2*phf_site)
regen_15 <- regen_15 %>% mutate(phf_site = 1/(3*15*5/10000)) %>% 
  mutate(ba_m2_ph = ba_m2*phf_site)
regen_50 <- regen_50 %>% mutate(phf_site = 1/(3*50*5/10000)) %>% 
  mutate(ba_m2_ph = ba_m2*phf_site)
```

Often in this script, data gets filtered to just live tree classes. Save the 
status codes for live trees so we can call it. 
```{r}
live_stat <- c("LS", "LL", "LF")
```

##Plotting colours
Define some consistent colours to plot with
```{r}
display.brewer.all(colorblindFriendly = TRUE)
?brewer.pal()

#Different site clusters
colors_clust <- c("dodgerblue", "dodgerblue4", "cadetblue2", "cadetblue4")

#Site ids
colors_site <- c(brewer.pal(3, "Oranges"), brewer.pal(5, "RdPu"),
       brewer.pal(3, "Blues"))

#spp colours Ba, Cw, Fd, Hw, other
#Make Hw blue so it matches below
levels(trees$spp2)
#Get names of colours
brewer.pal(5, "Paired")
#Define the palette so Hw is blue
colors_spp <- c("#A6CEE3", "#1F78B4", "burlywood", "burlywood4", "#FB9A99")

#hdm_pa colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$hdm_pa)
#Reorder factor so that healthy trees are plotted on the bottom
trees$hdm_pa <- fct_relevel(trees$hdm_pa, "Y", "U", "N", "-")
colors_hdm_pa <- c("goldenrod1", "grey", "#A6CEE3")

#dmr_f2 colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$dmr_f2)
colors_dmr_f2 = c("#1F78B4", "#A6CEE3", brewer.pal(4, "Oranges"), "hotpink")

#Crown third colours
colors_ct <- c("khaki1", "khaki3", "khaki4")
```

#SECTION 1: Site climate comparisons
Goal of this section is to descriptively describe differences in climate and 
physical variables (slope, aspect,elevation) between sites. 
The selected climate variables have a conceptual link to HDM biology -- see 
Barrett et al. (2012). There is a particlar focus on precipitation because
there seems to be relationship between cliamte and HDM spread in our data - 
the wetter (Pacific Highway sites) had relatively lower inf levels than the 
drier Campbell River cluster. 
```{r}
####Read in climate data
#Data downloaded from ClimateBC (https://climatebc.ca/mapVersion, 24 Jun 2024). ClimateBCv7.50. Period: Normal_1991_2020
#Exception: cr_3 site, surveyed 17 Jul 2024, downloaded data 25 Aug 2024
climate <- read_csv('./data/raw/hdm_sites_clim_data.csv') #raw data from climateBC

####Check coordinates were inputted correctly, then join site_ids 
#Sites are identified by coordinates in the climate dataset. Check they are right before joining site_ids
site <- site %>% mutate(dd_X_r = round(dd_X, digits = 4), #round number of decimals to match climateBC rounding
                        dd_Y_r = round(dd_Y, digits = 5))
x <- site$dd_X_r - climate$long
y <- site$dd_Y_r - climate$Lat
print(x); print(y)
#Good, almost al 0s, just one that is different by 1 x 10e-4 (a rounding error)

#Join site_id, bec and cluster by latitude values
climate <- left_join(climate, select(site, site_id, cluster, bec, dd_Y_r), by = c("Lat" = "dd_Y_r"))

#Move site_id to the front
climate <- climate %>% select(site_id, cluster, bec, everything())

#Define levels of bec zone in an order that corresponds to wettest to driest
levels(climate$bec)
climate <- climate %>% 
  mutate(bec = factor(bec, levels = c("CWHvm2", "CWHvm1", "CWHdm-", "CWHxm2")))

#Define climate variables that were in Barrett et al. (2012)
#Descriptions of these variables and whether they are exact matches or 
#approximations of variables used in paper are in: 
#/Users/hannosoutham/Library/CloudStorage/OneDrive-UBC(1)/Msc/Thesis/Ch1/
#climate variable notes.docx

#1 Growing degree days
climate <- climate %>% rowwise() %>% mutate(DD5_gs = sum(c_across(DD5_sp:DD5_at)))
select(climate, DD5, DD5_gs)

#2 Growing season radians
climate <- climate %>% rowwise() %>% mutate(Rad_gs = mean(c_across(Rad_sp:Rad_at)))
select(climate, MAR, Rad_gs)

#3 Lowest average minimum monthly temperature (Tmin_wt)
# find lowest Tmin value across all months
climate <- climate %>% rowwise() %>% mutate(Tmin_all = min(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_wt, Tmin_all)

#4 Standard deviation of lowest average minimum monthly temperature  
# calculate the standard deviation in Tmin across all of the months
climate <- climate %>% rowwise() %>% mutate(Tmin_sd = sd(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_sd)

#5 Snow (PAS) 
select(climate, MAP, PAS)

#6 Rain
climate <- climate %>% mutate(PAR = MAP-PAS)
select(climate, MAP, PAR, PAS)

#7 Lowest average spring monthly temperature
# Find lowest Tmin value between May and June
climate <- climate %>% rowwise() %>% mutate(Tmin_mj = min(c_across(Tmin_05:Tmin_06)))
select(climate, Tmin_mj)

#8 Lowest average fall monthly temperature (Tmin_at)
# Find the lowest Tmin value between August and September
climate <- climate %>% rowwise() %>% mutate(Tmin_as = min(c_across(Tmin_08:Tmin_09)))
select(climate, Tmin_as)

#Super. Filter the table to:
##Variables 1-8 defined above
##General descriptors (MAT, TD, MAP)
##Monthly precipitation estimates, total and as snow 
###David R. suggested presenting precipitation over season. The link to 
###precip is that rain or snow can pull HDM seeds off of foliage. 
climate <- climate %>% 
  select(site_id, cluster, bec, MAT, TD, MAP, PAR, PAS, DD5_gs, Rad_gs, 
         Tmin_all, Tmin_sd, Tmin_mj, Tmin_as, Prec_01:Prec_12, PAS_01:PAS_12) 
```

##Graph annual variables
```{r}
#Graph annual variables
#Create a long dataframe so a variables can be plotted in one go
clim_g <- climate %>%
  pivot_longer(MAT:Tmin_as, names_to = "climvar", values_to = "climval")

clim_g <- clim_g %>%
  mutate(climvar2 = case_match(climvar,
    "MAT" ~ "MAT~(italic(degree*C))",
    "TD" ~ "TD~(italic(degree*C))",
    "MAP" ~ "MAP~(italic(mm))",
    "PAR" ~ "PAR~(italic(mm))",
    "PAS" ~ "PAS~(italic(mm))",
    "DD5_gs" ~ "DD[5]~(italic(degree*C))",
    "Rad_gs" ~ "Rad[gs]~(italic(MJ~m^{-2}~d^{-1}))",
    "Tmin_all" ~ "Tmin[all]~(italic(degree*C))",
    "Tmin_sd" ~ "SD~Tmin~(italic(degree*C))",
    "Tmin_mj" ~ "Tmin[mj]~(italic(degree*C))",
    "Tmin_as" ~ "Tmin[as]~(italic(degree*C))"
  )) %>% 
  mutate(climvar2 = 
           factor(climvar2, levels = c("MAT~(italic(degree*C))", 
                                       "TD~(italic(degree*C))",
                                       "Tmin[all]~(italic(degree*C))",
                                       "SD~Tmin~(italic(degree*C))",
                                       "Tmin[mj]~(italic(degree*C))",
                                       "Tmin[as]~(italic(degree*C))",
                                       "Rad[gs]~(italic(MJ~m^{-2}~d^{-1}))",
                                       "DD[5]~(italic(degree*C))",
                                       "MAP~(italic(mm))",
                                       "PAR~(italic(mm))", 
                                       "PAS~(italic(mm))")))
unique(clim_g$climvar2)

#Create a plot
p <- ggplot(clim_g, aes(x=bec, y=climval, label=site_id, color = site_id)) +
  geom_jitter(width = 0.2, height = 0) +
  facet_wrap(~climvar2, scales = "free_y", labeller = label_parsed) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1, vjust = 0.5),
        legend.position = "right",
        legend.position.inside = c(0.88,0),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 7, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 0.05, 0.05,
                                                  unit = "cm")),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) +
  labs(x = "BEC", 
       y = "Climate variable value",
       colour = "Site") +
  scale_color_manual(values = colors_site)


#Export this plot
p <- ggsave(here("./figures/climate_vars.svg"), plot = p, device = "svg",
        width = 6.5, height = 5, units = "in")
```

##Explore monthly precipitation
HDM seed dispersal happens from late Sep-early Oct and then they have to 
overwinter. So winter precipitation is likely a key variable.  
```{r}
#Subset table to montly precip variables
mo_p <- climate %>% 
  select(site_id, cluster, bec, Prec_01:Prec_12, PAS_01:PAS_12)

#Lengthen table so total precip and precip as snow are in single columns and 
#each row represents a month
mo_p <- mo_p %>% 
  pivot_longer(cols = c(Prec_01:Prec_12, PAS_01:PAS_12),
               names_to = c(".value", "Month"),
               names_sep = "_")

#Calculate precipitation as rain
mo_p <- mo_p %>% 
  mutate(PAR = Prec - PAS)

#Graph precipitation over the year
#Lengthen again so precipitation is represented by a single column and whether
#it is rain or snow is identified by a second column
mo_p2 <- mo_p %>% 
  select(-Prec) %>% 
  pivot_longer(cols = c(PAS, PAR),
               names_to = "pre_type",
               values_to = "pre_mm") %>% 
  mutate(pre_type = case_match(pre_type,
                               "PAR" ~ "rain",
                               "PAS" ~ "snow")) %>% 
  mutate(pre_type = factor(pre_type, levels = c("snow", "rain")))

#Graph
colors_precip <- c("gray87", "gray30")
p <- ggplot(mo_p2, aes(x = Month, y = pre_mm, fill = pre_type)) +
  geom_bar(stat = "identity", position = "stack") + 
  facet_wrap(~site_id) +
  theme_classic() +
  scale_fill_manual(values = colors_precip) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "inside",
        legend.position.inside = c(0.88, 0.1),
        axis.text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 0.05, 0.05,
                                                  unit = "cm")),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) + 
  labs(x = "Month", y = "Precipitation (mm)", 
                                  fill = "Type")

#Export this plot
# ggsave(here("./figures/monthly_precip.svg"), plot = p, device = "svg",
#        width = 6.5, height = 5, units = "in")

#So there are some intuitive trends. The Pacific Highway sites are the wettest
#and it seems like the winter months contribute most to this difference
#Explore this a bit further. Calculate the difference between precip at a site
#and average precip across all sites for each month. Do the winter months have
#a larger difference?

#Calculate mean precip across sites for each month
x <- mo_p %>% 
  group_by(Month) %>% 
  summarise(allsite_Prec = mean(Prec))

#Add this back to the dataframe
mo_p <- left_join(mo_p, x, by = "Month")

#Calculate difference
mo_p <- mo_p %>% 
  mutate(Prec_diff = Prec - allsite_Prec)

#Graph this
p <- ggplot(mo_p, aes(x = Month, y = Prec_diff, color = site_id)) +
  geom_jitter(size = 2, height = 0, width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic() +
  theme(axis.text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) + 
  labs(x = "Month", y = "Difference from mean (mm)", 
       color = "Site") +
  guides(color = guide_legend(ncol = 2)) +
  scale_color_manual(values = colors_site)

#Export this plot
# ggsave(here("./figures/precip_diff.svg"), plot = p, device = "svg",
#        width = 6, height = 3, units = "in")
```

##Assemble output tables
Build clean tables combining physical and climate variables. We will 
create two: (1) a large one with site id, cluster, elevation, slope, aspect, 
BEC zone and all the climate variables that we can use in other downstream 
analyses and to create tables I didn't think of in the future and (2) a smaller 
one for thesis that includes site_id, cluster, elevation, slope, aspect and 
a few descriptive climate variables.

Start with table of climate variables and then add physical variables. Slope is 
a bit tricky here. There are two sets of slopes, slopes for the transect and 
slopes for the fall line. For both of thosesets we measured slope at multiple 
places to capture changes in slope profile. For the purpose of creating a 
descriptive table of site characteristics for writing, we will select the 
measurement that capture the general fall line slope of the regen component. 
Need to reference the notes in the csv to know which ones to pick here. 
```{r}
#Add elevation
climate$elevation <- site$elevation

#Subset transect data to slope variables
slope <- tran %>% select(site_id, transect_id, starts_with("fl"))

#Add declination
x <- site %>% select(site_id, Dec)
slope <- left_join(slope, x, by = "site_id")

#Two slopes were taken for fall line only at two sites (cr_1 and cr_2). Both
#cases were places where the mature component sloped into a creek. The first 
#measurement captured the bank down to the creek, the second captured the 
#profile in the regen. We want the second. 
slope <- slope %>% 
  mutate(reg_sl = if_else(!is.na(fl_sl2), fl_sl2, fl_sl1),
         reg_az = if_else(!is.na(fl_az2), fl_az2, fl_az1)
         )

#Then correct for declination for fall line azimuth measurements taken with the
#rangefinder. One case where suspected error (recorded as compass but should
#have been rangefinder); fix that.
slope <- slope %>% 
  mutate(fl_az_device = case_when(transect_id == 102 ~ "rangefinder",
                                  .default = fl_az_device))
slope <- slope %>% 
  mutate(reg_az_corr = case_match(fl_az_device,
                                  "compass" ~ reg_az,
                                  "rangefinder" ~ ((reg_az) + Dec)%%360))

#Summarize these by site (take mean)
slope <- slope %>% 
  group_by(site_id) %>% 
  summarise(reg_az = round(mean(reg_az), 1),
            reg_sl = round(mean(reg_sl), 1))

#Join these to the table
climate <- left_join(climate, slope, by = "site_id")
```

Export the tables. 
```{r}
#Subset a table for thesis
climate2 <- climate %>% select(site_id, cluster,
                                bec, elevation, reg_az, reg_sl,
                                MAT, Tmin_all, MAP, PAR, PAS)

#Export
# write_csv(climate, "./tables/site_climphys_big.csv")
# write_csv(climate2, "./tables/site_climphys_small.csv")
```

#SECTION 2: Size class distribution and species composition
Here we compare the composition and size class distribution of the trees 
between sites. We will use the 'regen_15' object for the regen component
because that is object contains only measured trees; it will be free from any
bias created by simulating trees. As a general principle, usually two versions
of each metric are created, one on a raw basis and one on a perhectare basis. 
```{r}
#Create a couple of dataframes to append results to
reg_cs <- site %>% select(site_id)
mat_cs <- site %>% select(site_id)
```

##Basal area, stem density
Start by basic site level metrics: basal area, number of stems. This is for all
measured trees (live and dead).
```{r}
#Regen
reg.ba_nstem <- regen_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2 = sum(ba_m2),
         reg.nstem = n(),
         reg.ba_m2_ha = sum(ba_m2_ph),
         reg.nstem_ha = sum(phf_site))

#Mature
mat.ba_nstem <- mature %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2 = sum(ba_m2),
         mat.nstem = n(),
         mat.ba_m2_ha = sum(ba_m2_ph),
         mat.nstem_ha = sum(phf_site, na.rm = TRUE))

#Join these to results table
reg_cs <- left_join(reg_cs, reg.ba_nstem, by="site_id")
mat_cs <- left_join(mat_cs, mat.ba_nstem, by="site_id")

#Print a summary table, see how they compare:
reg_cs %>% select(site_id, reg.ba_m2:reg.nstem_ha) %>% 
  arrange(reg.ba_m2_ha)
mat_cs %>% select(site_id, mat.ba_m2:mat.nstem_ha) %>% 
  arrange(mat.ba_m2_ha)
```

##DBH, codominant tree layer
Next, summarize the dbh of the codominant/dominant trees at each site. Do it 
across all species and then for hemlock. At a few trees, crown class is 
recorded for dead trees when it shouldn't be. Want this to be for live trees
so also filter for those. 
```{r}
#Regen
reg.dbh <- regen_15 %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C" & status %in% live_stat) %>% 
  summarise(reg.dbh_mean_cd_all = mean(dbh, na.rm = T),
            reg.dbh_sd_cd_all = sd(dbh, na.rm = T),
            reg.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            reg.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Mature
mat.dbh <- mature %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C" & status %in% live_stat) %>% 
  summarise(mat.dbh_mean_cd_all = mean(dbh, na.rm = T),
            mat.dbh_sd_cd_all = sd(dbh, na.rm = T),
            mat.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            mat.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Join these back to the results dataframes
reg_cs <- left_join(reg_cs, reg.dbh, by="site_id")
mat_cs <- left_join(mat_cs, mat.dbh, by="site_id")

#Take a look at them
reg_cs %>% select(site_id, contains("dbh")) %>% arrange(reg.dbh_mean_cd_all)
mat_cs %>% select(site_id, contains("dbh")) %>% arrange(mat.dbh_mean_cd_all)
```

##Percent makeup of Hw
Here, calculate how much of the basal area and stems at a site are made up of 
Hw. These are useful summary stats and tell us about host avaialbility across
the sites. 
```{r}
##Regen
reg.ba_nstem_hw <- regen_15 %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>%
  summarise(reg.ba_m2_hw = sum(ba_m2),
            reg.nstem_hw = n())
  
#Add to results dataframe
reg_cs <- left_join(reg_cs, reg.ba_nstem_hw, by="site_id")

#Calculate percent of total basal area and stems made up of hw
reg_cs <- reg_cs %>% 
  mutate(reg.p_ba_hw = 100*(reg.ba_m2_hw/reg.ba_m2),
         reg.p_stem_hw = 100*(reg.nstem_hw/reg.nstem))

##Mature
mat.ba_nstem_hw <- mature %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2_hw = sum(ba_m2),
            mat.nstem_hw = n())

##Add to results dataframe
mat_cs <- left_join(mat_cs, mat.ba_nstem_hw, by="site_id")
mat_cs <- mat_cs %>% 
  mutate(mat.p_ba_hw = 100*(mat.ba_m2_hw/mat.ba_m2),
         mat.p_stem_hw = 100*(mat.nstem_hw/mat.nstem))

##Print a summary table. 
#Hw makes up between 11 and 95% in regen and between 10% and 97% in mature 
#component. Two Ucluelet sites (ph_2 and ph_3) are outliers, with low 
#Hw percentages. Spread of Hw percentage more continuous in mature; 
#in regen, most sites have >70% Hw and only ph_2 and ph_3 are <50%. 
reg_cs %>% 
  select(site_id, reg.ba_m2, reg.ba_m2_hw, reg.p_ba_hw) %>% 
  arrange(reg.ba_m2)
mat_cs %>% select(site_id, mat.ba_m2, mat.ba_m2_hw, mat.p_ba_hw) %>% 
  arrange(mat.ba_m2)
```

##Basal area and stem density by species and diameter class
Break down basal area and stem density by species and diameter class. We can 
use this to create some graphs that summarize the tree composition at a site.
```{r}
#Do the breakdwon. A bit of a messy table, but graphed below
reg.struc <- regen_15 %>% group_by(site_id, spp, dbh_bin) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin, fill=list(ba_m2=0, nstem=0)) #add 0s in places there was no trees
mat.struc <- mature %>% group_by(site_id, spp, dbh_bin2) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin2, fill=list(ba_m2=0, nstem=0))#add 0s in places there was no trees

#Graph the species composition. See that Hw, Fd, Cw and Ba are major species
ggplot(reg.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
ggplot(mat.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
```

The major species at the sites are: Hw, Fd, Cw and Ba. We created a second
version of the species variable above that groups everything else as 'other'. 
Do the breakdown again and use this second species variable. Then use the 
breakdown to generate some plots, showing species composition across the sites. 
```{r}
#Summarize ba and nstems by species and diameter class again
#This time use spp2, which lists all non major spp as other
reg.struc <- regen_15 %>% 
  group_by(site_id, spp2, dbh_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2_ph), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin, fill=list(ba_m2_ha=0, nstem_ha=0)) #add 0s in places there was no trees

mat.struc <- mature %>% 
  group_by(site_id, spp2, dbh_bin2) %>% 
  summarise(ba_m2_ha = sum(ba_m2_ph), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha=0, nstem_ha=0))#add 0s in places there was no trees

#Regen
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
reg.struc <- reg.struc %>% filter(ba_m2_ha>0) 

#PLOT. 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(reg.struc, aes(x=dbh_bin, y=nstem_ha, fill=spp2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.05),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 11, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 0.05, 0.05,
                                                  unit = "cm")),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")
p

#Export this plot
# ggsave(here("./figures/reg_comp.svg"), plot = p, device = "svg",
#        width = 6.5, height = 5, units = "in")

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(reg.struc, aes(x=dbh_bin, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  

##Mature
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.struc <- mat.struc %>% filter(ba_m2_ha>0) #Remove rows with 0 because R will plot all dbh intervals (up to 180cm)

#PLOT 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(mat.struc, aes(x=dbh_bin2, y=nstem_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id), scales = "free_x") + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) +  
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 10, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 0.05, 0.05,
                                                  unit = "cm")),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")  
p

#Export this plot
# ggsave(here("./figures/mat_comp.svg"), plot = p, device = "svg",
#        width = 6.5, height = 8, units = "in")

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(mat.struc, aes(x=dbh_bin2, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  
```

##Summary table for thesis
We need to assemble a summary tables for 'the thesis' that generally describes
the forest at the sites. 

Regenerating component table:
- site_id, 
- years since harvest 
- stem density (and percent of Hw) 
- basal area (and propotion of Hw)
- height estimate of C/D Hw
- mean and sd of dbh for Hw

Mature component table:
- mature forest age estimates 
- stem density (and percent of Hw) 
- basal area (and propotion of Hw)
- mean and sd of dbh for Hw
- height estimate of C/D Hw

Start with stuff that is already in the site table. 
```{r}
#Start with a skeleton tables
reg_cs_the <- site %>% select(site_id)
mat_cs_the <- site %>% select(site_id)
```

Get age estimates. Mature forest age estimates ar in the vri dataframe. 
Load that. At some sitesmultiple vri polygons overlap the mature component. In 
those instances, use the average age estimate. 
Note: age estimates in cleaned vri dataset are corrected to account for 
difference between the year vri is projected to and when the site was measured
```{r}
vri <- read_csv(here("./data/cleaned/vri_c.csv"))

#Subset to polygons representing mature components
mat.age <- vri %>% filter(tree_type == "mature")
nrow(mat.age)

#Estimated age of Hw in the layer 1 trees is in the AGE_HW column. Get average.
mat.age <- mat.age %>% 
  group_by(site_id) %>% 
  summarise(mat.age_hw = mean(AGE_HW, na.rm = T))

#Join these to the summary table
mat_cs_the$mat.age_hw <- mat.age$mat.age_hw 

#Get age for regen from site data
reg_cs_the$yr_since_har <- site$age
```

Height estimates of the codominant/dominant Hw at each site are calcualted in 
the crown volume script and are stored in a table called top_ht.csv. Load that 
and calcualte the height difference. 
```{r}
th <- read_csv(here("./data/workflow/top_ht_wide.csv"))
head(th)
str(th)

#Sort by site id, order that is used throughout scripts
th <- th %>% arrange(site_id)

#Subset to just the relevant columns
x1 <- th %>% 
  select(site_id, n_ht_r_hdm, ht_r_C, source_r_ht)
x2 <- th %>% 
  select(site_id, n_ht_m_hdm, ht_m_C, source_m_ht)

#Join the relevant columns to the tables
reg_cs_the <- left_join(reg_cs_the, x1, by = "site_id")
mat_cs_the <- left_join(mat_cs_the, x2, by = "site_id")
```

To complete the job add the composition and dbh stats we created in this 
section. 
```{r}
#Then add dbh stats
reg_cs_the <- reg_cs_the %>% 
  mutate(reg.dbh_mean_cd_hw = reg_cs$reg.dbh_mean_cd_hw,
         reg.dbh_sd_cd_hw = reg_cs$reg.dbh_sd_cd_hw)

mat_cs_the <- mat_cs_the %>% 
  mutate(mat.dbh_mean_cd_hw = mat_cs$mat.dbh_mean_cd_hw,
         mat.dbh_sd_cd_hw = mat_cs$mat.dbh_sd_cd_hw)

#Add stem density and percent of stem that are Hw
reg_cs_the <- reg_cs_the %>% 
  mutate(reg.nstem_ha = reg_cs$reg.nstem_ha,
         reg.p_stem_hw =reg_cs$reg.p_stem_hw)
mat_cs_the <- mat_cs_the %>% 
  mutate(mat.nstem_ha = mat_cs$mat.nstem_ha,
         mat.p_stem_hw = mat_cs$mat.p_stem_hw)

#Then do the same but with basal area
reg_cs_the <- reg_cs_the %>% 
  mutate(reg.ba_m2_ha = reg_cs$reg.ba_m2_ha,
         reg.p_ba_hw = reg_cs$reg.p_ba_hw)
mat_cs_the <- mat_cs_the %>% 
  mutate(mat.ba_m2_ha = mat_cs$mat.ba_m2_ha,
         mat.p_ba_hw = mat_cs$mat.p_ba_hw)
```

##Export tables
Export the tables with all the summary stats calculated and the ones for 
writing. 
```{r}
#Export
# write_csv(reg_cs_the, here("./tables/reg_comp_size_the.csv"))
# write_csv(mat_cs_the, here("./tables/mat_comp_size_the.csv"))
# write_csv(reg_cs, here("./tables/reg_comp_size.csv"))
# write_csv(mat_cs, here("./tables/mat_comp_size.csv"))
```

#SECTION 3: Compare infection levels in mature trees
We will do this in two sections. The first section considers live and dead 
trees and creates some exploratory graphs. The second section focuses on live
trees and breaks infection down by crown class. 

Amabalis fir (Ba) is another HDM host that was a significant portion of one 
site (ph_2). We are going to exclude it from the general summary stats and 
graphs but summarize infection in it at ph_2 to add to the text of the 
results section.

##3.1 Infection in live and dead Hw
We will use the number of stems and basal area on a per hectare basis 
as metrics. Using both is useful because basal area captures biases in 
infection towards bigger or smaller trees. Generall speaking with these 
exploratory analyses, we are trying to assess whether the mature components are 
similar infection sources. 

Start by creating a dataframe to add results to and getting some basic metrics
```{r}
#Create a dataframe to append results to
m_i_ld_hw <- mat_cs %>% 
  select(site_id,  mat.nstem_ha, mat.ba_m2_ha)

#Filter to just Hw
mat.hw <- mature %>% filter(spp == "Hw")

#Calculate Hw basal area and number of stems on per hectare basis
x <- mat.hw %>% 
  group_by(site_id) %>% 
  summarise(mat.hw_nstem_ha = sum(phf_site), 
            mat.hw_ba_m2_ha = sum (ba_m2*phf_site))

#Add summary stats back to site data
m_i_ld_hw <- left_join(m_i_ld_hw, x, by="site_id")
```

###BA and # stems by P/A of HDM
Start simple and calculate the basal area and number of infected trees at 
each site. 
```{r}
#Because of the site with Ba that was infected, we'll calcualte total 
#infection with Ba and Hw and with just Hw
x <- mature %>% 
  filter(spp %in% c("Hw", "Ba") & hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(mat.hw_inf_ba_m2_ha = sum(ba_m2_ph[spp == "Hw"]), 
            mat.hw_inf_nstem_ha = sum(phf_site[spp == "Hw"]),
            mat.hwba_inf_ba_m2_ha = sum(ba_m2_ph), 
            mat.hwba_inf_nstem_ha = sum(phf_site)
            ) 

#Join variables back to working dataframe
m_i_ld_hw <- left_join(m_i_ld_hw, x, by="site_id") 

#Calculate the percent of all AND of Hw stems/BA infected
m_i_ld_hw <- m_i_ld_hw %>% 
  mutate(mat.p_ba_inf = 100*mat.hwba_inf_ba_m2_ha/mat.ba_m2_ha,
         mat.p_nstem_inf = 100*mat.hwba_inf_nstem_ha/mat.nstem_ha,
         mat.p_hw_ba_inf = 100*mat.hw_inf_ba_m2_ha/mat.hw_ba_m2_ha,
         mat.p_hw_nstem_inf = 100*mat.hw_inf_nstem_ha/mat.hw_nstem_ha) 
```

Take a look at the spread of infection across the sites by each metric. 
```{r}
#Summary tables sorted by percent of BA infected
#Including Ba and Hw
m_i_ld_hw %>% 
  select(site_id, mat.ba_m2_ha, mat.hw_ba_m2_ha, mat.hwba_inf_ba_m2_ha, 
         mat.p_ba_inf) %>% 
  arrange(mat.p_ba_inf) 

#Focus on Hw (only difference is at ph_2)
m_i_ld_hw %>% 
  select(site_id, mat.ba_m2_ha, mat.hw_ba_m2_ha, mat.hw_inf_ba_m2_ha, 
         mat.p_hw_ba_inf) %>% 
  arrange(mat.p_hw_ba_inf) 

#Summary table sorted by percent of stems infected
#Including Ba and Hw
m_i_ld_hw %>% select(site_id, mat.nstem_ha, mat.hw_nstem_ha, 
                         mat.hwba_inf_nstem_ha, mat.p_nstem_inf) %>% 
  arrange(mat.p_nstem_inf) 

#Just Hw (only difference is at ph_2)
m_i_ld_hw %>% select(site_id, mat.nstem_ha, mat.hw_nstem_ha, 
                         mat.hw_inf_nstem_ha, mat.p_hw_nstem_inf) %>% 
  arrange(mat.p_hw_nstem_inf) 
```

Graph this breakdown. Break down Hw BA and # of stems by site, presence/absence 
of HDM and dbhclass. This will provide a much more interpretable summary of how 
infection is distributed in the mature component. 
```{r}
mat.hdmpa_dbh <- mat.hw %>% 
  group_by(site_id, hdm_pa, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Because there are no non-host trees, the hdm_pa will now only have 
#trees in three of the four levels (Uknown, No, Yes)
levels(mat.hdmpa_dbh$hdm_pa)
mat.hdmpa_dbh %>% group_by(hdm_pa) %>% summarise(n_tree = n())

#Recode the factor the get rid of the fourth level
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% 
  mutate(hdm_pa = as.character(hdm_pa)) %>% 
  mutate(hdm_pa = factor(hdm_pa, levels = c("N", "U", "Y")))
#Check the levels
levels(mat.hdmpa_dbh$hdm_pa)

#Remove rows with 0 because R will plot all dbh intervals (300cm)
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% filter(ba_m2_ha > 0)

#Plot. # of stems
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=hdm_pa)) +  
  theme_classic() +
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N"))
  
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=hdm_pa)) + 
  theme_classic() +
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N")) 
```

###BA and # stems by DMR
This time, calculate the BA and number of stems on a per hectare basis in 
each DMR class at each site. 
```{r}
mat.dmr <- mat.hw %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(hw_ba_m2_ha = sum(ba_m2*phf_site), 
            hw_nstem_ha = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Filter out dmr class '-' because these are non-hosts trees
mat.dmr <- mat.dmr %>% filter(dmr_f2 != "-")

#Widen dataframe so each DMR class is a column
mat.dmr <- pivot_wider(mat.dmr, names_from = dmr_f2, 
                       values_from = c(hw_ba_m2_ha, hw_nstem_ha))

#Join these back to results table
m_i_ld_hw <- left_join(m_i_ld_hw, mat.dmr, by = "site_id")
```

Graph this breakdown
Break down Hw BA and # of stems (perha) by site, DMR and dbh  class. Then graph 
it. 
```{r}
mat.dmr_dbh <- mat.hw %>% 
  group_by(site_id, dmr_f2, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Check levels in DMR factor
#Because there is no non-hosts, can remove first level ("-")
levels(mat.dmr_dbh$dmr_f2)

#Recode this factor
mat.dmr_dbh <- mat.dmr_dbh %>% 
  mutate(dmr_f2 = as.character(dmr_f2)) %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("DU", "0", "IBLC", "1-2",
  "3-4", "5-6", "DI")))

#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.dmr_dbh <- mat.dmr_dbh %>% 
  filter(ba_m2_ha > 0) 

#Plot
#By number of stems
p <- ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.02),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 10, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 0.05, 0.05,
                                                  unit = "cm")),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold")) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "HDM infection")

#Export this plot
# ggsave(here("./figures/mat_inf_nstem_ha.svg"), plot = p, device = "svg",
#        width = 6.5, height = 5.0)

#By basal area
levels(mat.dmr_dbh$dmr_f2)
ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "none",
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 24),
        strip.text = element_text(size = 16)) + 
  labs(x = "DBH bin", y = expression("Basal area (m"^2*")"), 
       fill = "Adapted DMR")
```

##3.2 Infection in live Hw
Here we will use a set of standard infection metrics to describe HDM infection
in live Hw trees, broken down by crown class. 
```{r}
#Subset dataset to live Hw
mat.l_hw <- mat.hw %>% 
  filter(status %in% live_stat)

#Calculate infection metrics by crown class
x <- mat.l_hw %>% 
  group_by(site_id, crown_class_2) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3))

#Repeat but ingnoring crown class
x1 <- mat.l_hw %>% 
  group_by(site_id) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3)) %>% 
  mutate(crown_class_2 = "all")

#Combine
mat_i_l_hw <- rbind(x, x1)
```

##Infection metric plots
Plot these metrics. Here we will focus just on the codominant/dominant tree
layer. 
```{r}
#Lengthen the dataset
x <- mat_i_l_hw %>%
  filter(crown_class_2 == "C") %>% 
  pivot_longer(cols = where(is.numeric),
               names_to = "metric",
               values_to = "value") %>% 
  mutate(metric_group = if_else(str_detect(metric, "p"), "Incidence (%)", 
                                "DMR"))

#Plot
ggplot(x, aes(x = metric, y = value)) + 
  facet_wrap(~metric_group, scales = "free") +
  expand_limits(y = c(0,6)) +
  geom_jitter(width = 0.1,
              height = 0) + 
  geom_boxplot(outliers = F, fill = NA) +
  theme_classic() 

#Create plot for defence presentation that omits incidence of brooming and 
#stem infections
x1 <- x %>% 
  filter(!metric %in% c("p_l_hw_wb", "p_l_hw_si")) %>% 
  mutate(metric = case_match(metric,
                             "p_l_hw_inf" ~ "Incidence",
                             "p_l_hw_dmr3" ~ "DMR ≥3 incidence",
                             "hw_s_dmr" ~ "Average DMR",
                             "hw_s_dmi" ~ "DMI")) %>% 
  mutate(metric = factor(metric, levels = c("Incidence", "DMR ≥3 incidence",
                                            "Average DMR", "DMI")))

#Subset dataframe to metrics that are incidence based and dmr based
x2 <- x1 %>% 
  filter(metric_group == "Incidence (%)")
x3 <- x1 %>% 
  filter(metric_group == "DMR")

#This is the colour scheme used in thesis for plot that shows both mature and 
#regen summary stats. We will just use orange colour here. 
c("#a6611a", "#018571", "#80cdc1")

#Plot incidence based metrics
p1 <- ggplot(x2, aes(x = metric, y = value)) + 
  geom_point(position = position_dodge(width = 0.75), color = "#a6611a") + 
  geom_boxplot(outliers = F, fill = NA, color = "#a6611a") +
  lims(y = c(0, 100)) +
  theme_classic() +
  labs(x = "Infection metric",
       y = "%") +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.5), units = "cm"))

#Plot metrics on DMR scale
p2 <- ggplot(x3, aes(x = metric, y = value)) + 
  geom_point(position = position_dodge(width = 0.75), color = "#a6611a") + 
  geom_boxplot(outliers = F, fill = NA, color = "#a6611a") +
  lims(y = c(0, 6)) +
  theme_classic() +
  labs(x = NULL,
       y = "DMR scale") +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.5), units = "cm"))

#Combine
p3 <- ggarrange(p1, p2, ncol = 2, align = "h",
                widths = c(1, 1), labels = "AUTO", vjust = 1.2, 
                hjust = -0.1, font.label = list(size = 13, 
                                                family = "Times New Roman",
                                                face = "bold"))

p3

#Save
# ggsave(here("./figures/mat_inf_met_def.svg"), plot = p3, device = "svg",
#        width = 20, height = 15, units = "cm")
```

##Summary table for thesis
Compile a summary table for thesis with infection metrics in live Hw by crown
class. 
  - Variables: 
    - Percent live Hw trees infected 
    - Percent live Hw with DMR >= 3
    - Percent of live Hw trees with brooms
    - Percent of live Hw trees with stem infection
    - Average DMR (live Hw)
    - DMI (live Hw dmr>=1)
  - Structure:
    - Rows: variables (mean, median, min, max)
    - Columns: crown class
```{r}
mat_i_l_hw %>% filter(crown_class_2 == "C") %>% summary()

mat_i_l_hw_sum <- mat_i_l_hw %>% 
  group_by(crown_class_2) %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}"))

#Reorder columns
names(mat_i_l_hw_sum)
mat_i_l_hw_sum <- mat_i_l_hw_sum %>% 
   mutate(crown_class_2 = if_else(crown_class_2 == "all", "All",
                                 crown_class_2)) %>% 
  arrange(crown_class_2) %>% 
  select(crown_class_2, starts_with("p_l_hw_inf"),
         starts_with("p_l_hw_dmr3"),
         starts_with("p_l_hw_wb"), starts_with("p_l_hw_si"),
         starts_with("hw_s_dmr"), starts_with("hw_s_dmi"))

#Export
# write_csv(mat_i_l_hw_sum, here("./tables/mat_inf_l_hw.csv"))
```

##Amabalis fir, ph2 mature
Amabalis fir is rated as an occasional host of HDM (Mathiasen, 2021) and was 
only present at one site (ph_2). Generate/call some summary stats to report its 
infection at that site. Stats:
  -Site basal area/ha
  -Site trees/ha
  -Af/Hw basal area/ha
  -Af/Hw trees/ha
  -Percent of site basal area made up of Af/Hw
  -Percent of site stems made up of Af/Hw
  -Incidence of infection in live Af/Hw trees
  -Af/Hw average DMR
  -Af/Hw DMI

Note: for clarity, Amabilis fir two letter code is Ba. But to avoid confusion 
with basal area, it is abbreviated with af (except when 
the code is calling the species code in the data). 
```{r}
#Filter mature dataset to just Ba
mat.af <- mature %>% filter(spp == "Ba")
nrow(mat.af) #18 trees
unique(mat.af$site_id) #only at ph_2

#Generate some summary stats:
ph2.mat <- mature %>% 
  filter(site_id == "ph_2") %>% 
  summarise(nstem_ha = sum(phf_site),
            af_nstem_ha = sum(phf_site[spp == "Ba"]),
            hw_nstem_ha = sum(phf_site[spp == "Hw"]),
            ba_m2_ha = sum(ba_m2_ph),
            af_ba_m2_ha = sum(ba_m2_ph[spp == "Ba"]),
            hw_ba_m2_ha = sum(ba_m2_ph[spp == "Hw"]),
            l_af_nstem_ha = sum(phf_site[status %in% live_stat & spp == "Ba"]),
            l_hw_nstem_ha = sum(phf_site[status %in% live_stat & spp == "Hw"]),
            li_af_nstem_ha = sum(phf_site[status %in% live_stat &
                                            spp == "Ba" & hdm_pa == "Y"]),
            li_hw_nstem_ha = sum(phf_site[status %in% live_stat & 
                                            spp == "Hw" & hdm_pa == "Y"]),
            s.af_dmr = mean(dmr[status %in% live_stat & spp == "Ba"]),
            s.hw_dmr = mean(dmr[status %in% live_stat & spp == "Hw"]),
            s.af_dmi = mean(dmr[status %in% live_stat & spp == "Ba" & 
                                  dmr >= 1]),
            s.hw_dmi = mean(dmr[status %in% live_stat & spp == "Hw" & 
                                  dmr >= 1])) %>% 
  mutate(p_nstem_af = 100*af_nstem_ha/nstem_ha,
         p_nstem_hw = 100*hw_nstem_ha/nstem_ha,
         p_ba_af = 100*af_ba_m2_ha/ba_m2_ha,
         p_ba_hw = 100*hw_ba_m2_ha/ba_m2_ha,
         p_l_af_nstem_inf = 100*li_af_nstem_ha/l_af_nstem_ha,
         p_l_hw_nstem_inf = 100*li_hw_nstem_ha/l_hw_nstem_ha)

#Compare with Hw at site
##What is site total nstem_ha and ba_ha
ph2.mat %>% select(nstem_ha, ba_m2_ha)

##How much of the site nstem_ha and ba_ha are made of of Hw and Ba?
###The two spp are pretty similar
ph2.mat %>% select(p_nstem_af, p_nstem_hw, p_ba_af, p_ba_hw)

##What % of live Hw and Ba at each site are infected?
###Infection rates higher in Hw
ph2.mat %>% select(p_l_af_nstem_inf, p_l_hw_nstem_inf)

#What is the mean DMR and DMI of Hw and Ba?
###Infection more severe in Hw than Ba
ph2.mat %>% select(s.af_dmr, s.hw_dmr, s.af_dmi, s.hw_dmi)

#There were some large cedar at this site. Take a look at a few of them to see
#what the range of dbh is
mature %>% 
  filter(site_id == "ph_2" & spp == "Cw" & 
           crown_class_2 == "C") %>% head()
```

#SECTION 4 - Compare infection levels in regen trees
This section focuses on Hw (because it is our target tree). Again there is a 
some code at the end that creates some summary statistics for Amabalis fir (Ba)
at ph_2. 

It is broken into two major subsections. The first that looks at infections 
across live and dead trees hemlock, while the second looks just at live 
hemlock. 

Both subsections break summary stats down into intervals from the edge. 
  - 0-15m which is within the zone of influence of the mature component and 
  only contains measured trees
  - 0-50 which extends past the zone of influence and will contain simulated 
  trees for all but one site, to varying extents 

Start by removing residual trees from the regen datasets. 
```{r}
#Read in residual tree dataset
resid <- read_csv(here("./data/raw/resid_ref_tree_data.csv"))

#How many residual trees are there? 
resid <- resid %>% filter(tree_type == "residual")
nrow(resid) #10

#How many are on a regen transect?
resid %>% filter(!is.na(regen_tree_id)) %>% nrow() #5

#Lets remove these from the trees datasets
resid_rm <- resid %>% filter(!is.na(regen_tree_id)) %>% 
  pull(regen_tree_id)

#Add column to trees datasets that identifies which trees are residuals
regen_15 <- regen_15 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))
regen_50 <- regen_50 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))

#How many are <15m from edge?
regen_15 %>% select(resid) %>% table()

#How many are >50m from the edge?
regen_50 %>% select(resid) %>% table()

#Filter out the residual trees
regen_15 <- regen_15 %>% filter(resid == "N")
regen_50 <- regen_50 %>% filter(resid == "N")
```

##4.1 Infection in live and dead regen Hw
Create an object to append results to and subset the two working 
dataframes to just Hw trees. 
```{r}
#Create dataframe to append results to
reg_i_all <- site %>% 
  select(site_id)

#Subset two trees objects
reg.hw_15 <- regen_15 %>% 
  filter(spp == "Hw")
reg.hw_50 <- regen_50 %>% 
  filter(spp == "Hw")
```

Estimate total Hw basal area and number of stems per hectare. 
```{r}
reg.hw_ba_nstem_15 <- reg.hw_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_15 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_15 = sum(phf_site))
reg.hw_ba_nstem_50 <- reg.hw_50 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_50 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_50 = sum(phf_site))

#Join estimates to working results dataframe
reg_i_all <- left_join(reg_i_all, reg.hw_ba_nstem_15, by="site_id")
reg_i_all <- left_join(reg_i_all, reg.hw_ba_nstem_50, by="site_id")
```

###How many trees were simulated?
Calculate the percent of all trees and Hw simulated at each site. 
```{r}
#Get counts of all trees, all simulated trees, all Hw and simulated Hw
reg.sim <- regen_50 %>% 
  group_by(site_id) %>% 
  summarise(nstem_all = n(),
            nstem_sim = sum(sim_tree == "Y"),
            nstem_hw = sum(spp == "Hw"),
            nstem_hw_sim = sum (spp=="Hw" & sim_tree == "Y"))

#Calculate percents
reg.sim <- reg.sim %>% 
  mutate(reg.p_sim = 100*nstem_sim/nstem_all,
         reg.p_hw_sim = 100*nstem_hw_sim/nstem_hw)

#Join these back to the working results dataframe
x <- reg.sim %>% select(site_id, starts_with("reg.p"))
reg_i_all <- left_join(reg_i_all, x, by = "site_id")
```

###BA and nstems infected
Calculate the basal area and # of stems infected (per ha) at each site and with
those the percent infection by each metric. General trends:
  - percent infected (0-15m): mean = 0.49, range =0.01 - 0.80
  - percent infected (0-50): mean = 0.24, range = 0 - 0.56
  - Four outliers are obvious in this data: mk_3 (youngest site by far), 
  ph_1 (no clear explanation), ph_2 and ph_3 (both sites where Hw is not a 
  dominant species)
```{r}
reg.ba_nstem_inf_15 <- reg.hw_15 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_15 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_15 = sum(phf_site))

reg.ba_nstem_inf_50 <- reg.hw_50 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_50 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_50 = sum(phf_site))

#Join these stats back to results dataframe
reg_i_all <- left_join(reg_i_all, reg.ba_nstem_inf_15, by="site_id")
reg_i_all <- left_join(reg_i_all, reg.ba_nstem_inf_50, by="site_id")

#Calculate the percent of Hw infected
reg_i_all <- reg_i_all %>% 
  mutate(reg.p_ba_m2_inf_15 = 100*reg.ba_m2_ha_hw_inf_15/reg.ba_m2_ha_hw_15,
         reg.p_nstem_inf_15 = 100*reg.nstem_ha_hw_inf_15/reg.nstem_ha_hw_15,
         reg.p_ba_m2_inf_50 = 100*reg.ba_m2_ha_hw_inf_50/reg.ba_m2_ha_hw_50,
         reg.p_nstem_inf_50 = 100*reg.nstem_ha_hw_inf_50/reg.nstem_ha_hw_50)

#Take a look
#For 0-15m
reg_i_all %>% select(site_id, reg.ba_m2_ha_hw_15, reg.nstem_ha_hw_15,
                         reg.p_ba_m2_inf_15, reg.p_nstem_inf_15) %>% 
  arrange(reg.p_nstem_inf_15)
summary(reg_i_all$reg.p_nstem_inf_15)

#For 0-50m
reg_i_all %>% select(site_id, reg.ba_m2_ha_hw_50, reg.nstem_ha_hw_50,
                         reg.p_ba_m2_inf_50, reg.p_nstem_inf_50) %>% 
  arrange(reg.p_nstem_inf_50)
summary(reg_i_all$reg.p_nstem_inf_50)
```

###Basal area and # of stems by DMR
Break down basal area and the number of stems (per ha) by DMR class.
```{r}
#Now find the basal area and number of stems (per ha) in each dmr class
reg.dmr_15 <- reg.hw_15 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_15 = sum(ba_m2*phf_site), 
            nstem_ha_15 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_15 <- reg.dmr_15 %>% 
  filter(dmr_f2 != "-")
reg.dmr_15 <- pivot_wider(reg.dmr_15, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_15, nstem_ha_15))

reg.dmr_50 <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_50 = sum(ba_m2*phf_site), 
            nstem_ha_50 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_50 <- reg.dmr_50 %>% 
  filter(dmr_f2 != "-")
reg.dmr_50 <- pivot_wider(reg.dmr_50, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_50, nstem_ha_50))

#Add these to results dataframe
reg_i_all <- left_join(reg_i_all, reg.dmr_15, by = "site_id")
reg_i_all <- left_join(reg_i_all, reg.dmr_50, by = "site_id")
```

####Graph this breakdown
Break down basal area and # of stems (per ha) by DMR class and distance from 
the edge. This is a pretty close to visual to what we are trying to model. 

Start by breaking distance from the edge into bin and then creating the 
dataframe with the breakdown.
```{r}
#Break distance from the edge into 5m bins
reg.hw_50 <- reg.hw_50 %>% 
  mutate(dist_y_h_bin = cut(dist_y_h, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))
reg.hw_50$dist_y_h_bin
  
#Do the breakdown
reg.dmr_disty <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2, dist_y_h_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>%
  complete(dist_y_h_bin, fill=list(ba_m2_ha = 0, nstem_ha = 0))
```

We want to indicate where measured trees stop and simulated trees begin at each
site. To do that, we need to find the last interval with measured data. We can 
add a label to the plot that indicates that's where measurements stopped. A few
sites had different length transects, when we extended a transect to cover some 
landscape feature (like a blowdown patch). We will just put a marker at the 
last interval that has some measured data at a site. This is somewhat 
unrepresentative because at the sites with varied transect length, there will 
be some data between the marker and 0 that is simualted. But it was creating
confusion when people reviewed the thesis. The proportion of simulated 
data are reported in other places and I don't think this choice changes the 
interpretation of the data. 
```{r}
#Create data identifying the last interval with measured data at each site
#With help from ChatGPT
sim_lab <- reg.hw_50 %>%
  filter(tree_type_2 == "meas regen") %>%  # Keep only "meas regen" trees
  group_by(site_id) %>%  # Group by site
  slice_max(dist_y_h, n = 1, with_ties = FALSE) %>%  # Get the row with max dist_y_h per site
  select(site_id, dist_y_h_bin)  # Select relevant columns

#Get the total bar height for a graph using number of stems and a graph using
#BA. We will use this to define the y - coordinate for the marker
x <- reg.dmr_disty %>% 
  group_by(site_id, dist_y_h_bin) %>% 
  summarise(lab_pos_ba = sum(ba_m2_ha),
            lab_pos_nstem = sum(nstem_ha))

#Join this to the plotting dataframe
sim_lab <- left_join(sim_lab, x,
                           by = c("site_id", "dist_y_h_bin"))
```

Then graph. 
```{r}
#By BA
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=ba_m2_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(data = sim_lab, aes(y = lab_pos_ba, label = "s", vjust = 0.1,
                                fill = NULL)) +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2, 
                    labels = c("Dead uninfected", "0",
                                 "Infected below \nlive crown",
                                 "1-2",
                                 "3-4",
                                 "5-6",
                                 "Dead uninfected")) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.01),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 20)) + 
  labs(x = "Distance from edge (m)", 
       y = expression("Basal area (m"^2*") per ha"), 
       fill = "Adapted DMR") + 
  guides(fill = guide_legend(ncol = 1))

#Export this plot
# pdf(here("./figures/reg_dmr_disty_ba.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#By # of stems
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=nstem_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(data = sim_lab, aes(y = lab_pos_nstem, label = "s", 
                                vjust = -.5, fill = NULL), 
            size = 4, family = "Times New Roman") +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  ylim(0, 800) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.05),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                    face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        axis.text = element_text(size = 10, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 
                                                  0.05, 0.05, "cm"))) + 
  labs(x = "Distance from edge (m)", 
       y = "Trees per ha", 
       fill = "HDM infection") + 
  guides(fill = guide_legend(ncol = 2))

#Export this plot
# ggsave(here("./figures/reg_dmr_disty_nstem.svg"), plot = p, device = "svg",
#        width = 6.5, height = 5, units = "in")
```

##4.2 Infection in live regen Hw
When comparing to other papers, it became important to have infection metrics
for live trees and broken down by crown class. Most other papers report 
infection metrics for the something analagous to the live codominant layer so 
we need this for comparison. Infection metrics for these trees are created in
this subsection.

Filter to live Hw
```{r}
regen_15_l <- regen_15 %>% 
  filter(spp == "Hw" & status %in% live_stat & 
           sim_tree == "N")
regen_50_l <- regen_50 %>% 
  filter(spp == "Hw" & status %in% live_stat)
```

Summarize infection at the site level
```{r}
#Calcualte summary metrics at the site level broken down by crown class
#For 0 - 15m
x <- regen_15_l %>% 
  group_by(site_id, crown_class_2) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3)) %>% 
  mutate(sec = "0_15")


#For 0-50m 
x1 <- regen_50_l %>% 
  group_by(site_id, crown_class_2) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3)) %>% 
  mutate(sec = "0_50")

#Do the same thing but ignoring crown class
#Calculate each variable at the site level
#For 0-15m
x2 <- regen_15_l %>% 
  group_by(site_id) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, 
            nstem_ha_l_hw_wb, nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3)) %>% 
  mutate(crown_class_2 = "all", sec = "0_15")
  

#For 0-50m
x3 <- regen_50_l %>% 
  group_by(site_id) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            hw_s_dmr = mean(dmr),
            hw_s_dmi = if_else(length(dmr[dmr>=1]) > 0,
                            mean(dmr[dmr>=1]),
                            NA),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"]),
            nstem_ha_l_hw_dmr3 = sum(phf_site[dmr >= 3])) %>% 
  mutate(p_l_hw_inf = 100*nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = 100*nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = 100*nstem_ha_l_hw_si/nstem_ha_l_hw,
         p_l_hw_dmr3= 100*nstem_ha_l_hw_dmr3/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, 
            nstem_ha_l_hw_wb, nstem_ha_l_hw_si, nstem_ha_l_hw_dmr3)) %>% 
  mutate(crown_class_2 = "all", sec = "0_50")

#Join the three dataframes
ri_l_hw <- rbind(x, x1, x2, x3)

#Get some summary stats
ri_l_hw %>% filter(sec == "0_15" & crown_class_2 == "C") %>% summary()
ri_l_hw %>% filter(sec == "0_50" & crown_class_2 == "C") %>% summary()
```

Generate some summary stats with a bit more detail about the trees where growth
impacts are occruing in dominant/codominant trees. 
```{r}
#How many are there? 
#All within 15m
regen_hw_dmr3 <- regen %>% 
  filter(spp == "Hw" & status %in% live_stat & dmr >= 3 & crown_class_2 == "C")
dim(regen_hw_dmr3) #41

#Where are these trees relative to the edge? 
#All within 15m 
summary(regen_hw_dmr3$dist_y_h)

#Which sites have them? 
unique(regen_hw_dmr3$site_id)

#What is there typical incidence?
x %>% filter(crown_class_2 == "C") %>% 
  select(p_l_hw_dmr3) %>% summary()
```

###Plot for thesis
Here we will combine the summary metrics for the mature component and the ones
for the regenertaing component into one plot. 
```{r}
#Compare tables in mature and regen component to figure out what we need to 
#do to align them
#Regen table has an extra column called "sec". Need to make a variable 
#identifying three groups: mature, regen from 0-15m and regen from 0-50m
head(mat_i_l_hw)
head(ri_l_hw)

#Combine the tables
x <- ri_l_hw %>% 
  mutate(tree_group =paste0("regen_", sec)) %>% 
  select(-sec) %>% 
  mutate(tree_group = case_match(tree_group,
                                 "regen_0_15" ~ "Regen 0-15 m",
                                 "regen_0_50" ~ "Regen 0-50 m"))
x1 <- mat_i_l_hw %>% 
  mutate(tree_group = "Mature")
x2 <- rbind(x, x1)

#Filter the table above to the co-dominant tree layer
x2 <- x2 %>% 
  filter(crown_class_2 == "C")

#Create a variable grouping the infection metrics by their measurement scale
#Two scales: metrics based on incidence (%) and those based on DMR
#Lengthen the dataset
x2 <- x2 %>% 
  pivot_longer(cols = where(is.numeric),
               names_to = "metric",
               values_to = "value") %>% 
  mutate(metric_group = if_else(str_detect(metric, "p"), "Incidence (%)", 
                                "DMR"))

#Rename and order variables so they are legible and display in specific order
#in the plot
unique(x2$metric)
x2 <- x2 %>% 
  mutate(metric = case_match(metric,
                             "hw_s_dmr" ~ "Average DMR",
                             "hw_s_dmi" ~ "DMI",
                             "p_l_hw_inf" ~ "Incidence",
                             "p_l_hw_wb" ~ "Brooming incidence",
                             "p_l_hw_si" ~ "Stem infection incidence",
                             "p_l_hw_dmr3" ~ "DMR ≥3 incidence")) %>% 
  mutate(metric = factor(metric, levels = c("Incidence", 
                                            "DMR ≥3 incidence",
                                            "Brooming incidence",
                                            "Stem infection incidence", 
                                            "Average DMR",
                                            "DMI")),
         metric_group = factor(metric_group, levels = c("Incidence (%)",
                                                        "DMR")))

#Subset dataframe to metrics that are incidence based and dmr based
x3 <- x2 %>% 
  filter(metric_group == "Incidence (%)")
x4 <- x2 %>% 
  filter(metric_group == "DMR")

#Define some colours
colors_tree_group <- c("#a6611a", "#018571", "#80cdc1")

#Plot
p1 <- ggplot(x3, aes(x = metric, y = value, shape = tree_group, 
                     colour = tree_group)) + 
  geom_point(position = position_dodge(width = 0.75)) + 
  geom_boxplot(outliers = F, fill = NA,
               show.legend = F) +
  theme_classic() +
  scale_color_manual(values = colors_tree_group) +
  labs(x = "Infection metric",
       y = "%",
       shape = "Tree group",
       color = "Tree group") +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        strip.text = element_text(size = 11, family = "Times New Roman"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                    face = "bold"),
        legend.position = "bottom",
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.5), units = "cm"))

p2 <- ggplot(x4, aes(x = metric, y = value, shape = tree_group,
               colour = tree_group)) + 
  geom_point(position = position_dodge(width = 0.75)) + 
  geom_boxplot(outliers = F, fill = NA,
               show.legend = F) +
  lims(y = c(0, 6)) +
  theme_classic() +
  scale_color_manual(values = colors_tree_group) +
  labs(x = NULL,
       y = "DMR scale",
       shape = "Tree group",
       color = "Tree group") +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman"),
        strip.text = element_text(size = 11, family = "Times New Roman"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                    face = "bold"),
        legend.position = "bottom",
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.5), units = "cm"))

p3 <- ggarrange(p1, p2, ncol = 2, common.legend = T, align = "h",
                widths = c(1.7, 1), labels = "AUTO", vjust = 1.2, 
                hjust = -0.1, font.label = list(size = 13, 
                                                family = "Times New Roman",
                                                face = "bold"),
                legend = "top")

#Save
# ggsave(here("./figures/inf_metrics.svg"), plot = p3, device = "svg",
#        width = 6.5, height = 4, units = "in")
```

###Plot for defence
Pulls out regenerating trees from 0-15 m and omits the incidence of brooming 
and stem infections. 
```{r}
#Rename two intervals in regenerating component for legend
#Filter to dominant/codominant crown class and trees within 15 m of the edge
x <- ri_l_hw %>% 
  filter(crown_class_2 == "C" & sec == "0_15")

#Create a variable grouping the infection metrics by their measurement scale
#Two scales: metrics based on incidence (%) and those based on DMR
#Lengthen the dataset
x <- x %>% 
  pivot_longer(cols = where(is.numeric),
               names_to = "metric",
               values_to = "value") %>% 
  mutate(metric_group = if_else(str_detect(metric, "p"), "Incidence (%)", 
                                "DMR"))

#Rename and order variables so they are legible and display in specific order
#in the plot
unique(x$metric)
x <- x %>% 
  mutate(metric = case_match(metric,
                             "hw_s_dmr" ~ "Average DMR",
                             "hw_s_dmi" ~ "DMI",
                             "p_l_hw_inf" ~ "Incidence",
                             "p_l_hw_wb" ~ "Brooming incidence",
                             "p_l_hw_si" ~ "Stem infection incidence",
                             "p_l_hw_dmr3" ~ "DMR ≥3 incidence")) %>% 
  mutate(metric = factor(metric, levels = c("Incidence", 
                                            "DMR ≥3 incidence",
                                            "Brooming incidence",
                                            "Stem infection incidence", 
                                            "Average DMR",
                                            "DMI")),
         metric_group = factor(metric_group, levels = c("Incidence (%)",
                                                        "DMR")))


#Subset dataframe to metrics that are incidence based and dmr based
#Filter out incidence of brooming and stem infections
x1 <- x %>% 
  filter(metric_group == "Incidence (%)" & metric %in% c("Incidence", 
                                                         "DMR ≥3 incidence"))
x2 <- x %>% 
  filter(metric_group == "DMR")

#These are the colours used for full plot with mature, regen 0-15 m and regen
#0-50 m plot. We will just use the dark blue colour
c("#a6611a", "#018571", "#80cdc1")

#Plot
p1 <- ggplot(x1, aes(x = metric, y = value)) + 
  geom_point(colour = "#018571") + 
  geom_boxplot(outliers = F, fill = NA, colour = "#018571") +
  theme_classic() +
  labs(x = "Infection metric",
       y = "%") +
  lims(y = c(0, 100)) +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"))

p2 <- ggplot(x2, aes(x = metric, y = value)) + 
  geom_point(position = position_dodge(width = 0.75),
             colour = "#018571") + 
  geom_boxplot(outliers = F, fill = NA,
               show.legend = F, colour = "#018571") +
  theme_classic() +
  labs(x = NULL,
       y = "DMR scale") +
  lims(y = c(0, 6)) +
  theme(axis.text.x = element_text(angle = 35, hjust=1, size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"),
        axis.text.y = element_text(size = 11, 
                                   family = "Times New Roman",
                                   colour = "black"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"))

p3 <- ggarrange(p1, p2, ncol = 2, common.legend = T, align = "h",
                widths = c(1, 1), labels = "AUTO", vjust = 1.2, 
                hjust = -0.1, font.label = list(size = 13, 
                                                family = "Times New Roman",
                                                face = "bold"),
                legend = "top")
p3

#Save
# ggsave(here("./figures/reg_inf_met_def.svg"), plot = p3, device = "svg",
#        width = 20, height = 15, units = "cm")
```

###Summary table for thesis
For the table,
Variables:
  - Percent of Hw stems infected
  - Percent Hw trees DMR ≥ 3 (where growth impacts occur)
  - Percent Hw stems with brooms
  - Percent Hw stems with stem infections
  - Average DMR
  - DMI
Structure: 
  - Rows: 
    - Interval (distnace from the edge; all, 0-15m or 0-50)
    - Crown class (all, C, I, S)
  - Columns: variables (mean, median, min, max)
  
For reference: 
  - Average DMR = mean DMR of all live hemlock trees (an proxy of infection 
  severity at a site)
  - DMI = mean DMR of all live hemlock trees with dmr>=1 (a proxy of infection 
  severity where infection occurs)
```{r}
#Summarize across sites, grouping by interval and crown class
ri_l_hw_sum <- ri_l_hw %>% 
  group_by(sec, crown_class_2) %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(., na.rm = T),
    median = ~median(., na.rm = T),
    min = ~min(., na.rm = T),
    max = ~max(., na.rm = T)
  ), .names = "{.col}_{.fn}")) %>% 
  mutate(crown_class_2 = if_else(crown_class_2 == "all", "All",
                                 crown_class_2)) %>% 
  arrange(sec, crown_class_2)


#Sort rows and columns
names(ri_l_hw_sum)
ri_l_hw_sum <- ri_l_hw_sum %>% 
   mutate(crown_class_2 = if_else(crown_class_2 == "all", "All",
                                 crown_class_2)) %>% 
  arrange(sec, crown_class_2) %>% 
  select(sec, crown_class_2, starts_with("p_l_hw_inf"), 
         starts_with("p_l_hw_dmr3"),
         starts_with("p_l_hw_wb"), starts_with("p_l_hw_si"),
         starts_with("hw_s_dmr"), starts_with("hw_s_dmi"))

#Export
# write_csv(ri_l_hw_sum, here("./tables/reg_inf_hw_live.csv"))
```

###Distance of spread
Use some summary metrics to capture how far HDM has spread (in live Hw).
  - Infection perimeter = distance from the edge below which 
  90% of the infected live Hw occur. 
    - Its better than using the most distant tree 
    because it uses more than just one datapoint; the exception is when there 
    is just one or two infected trees at a site. In those cases, it will be
    disproportinately determined by those trees.
  - Outer infected tree = infected live Hw most distant from the mature forest
  edge
  
Infection perimeter
```{r}
#Calcualte at the transect level first
#Used if_else statement because if there are no infected Hw, then infection
#perimeter is 0
reg.infper_tran <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & tree_type_2 == "meas regen" & 
           spp == "Hw" & status %in% live_stat) %>% 
  group_by(site_id, plot_id) %>% 
  summarise(infper = if_else(sum(hdm_pa == "Y")>0, 
                                 quantile(dist_y_h[hdm_pa == "Y"], probs = 0.9),
                                 0)) 
range(reg.infper_tran$infper)

#Average across transects to get site level estimate
reg.infper_site <- reg.infper_tran %>% 
  group_by(site_id) %>% 
  summarise(infper_mean = mean(infper), 
            infper_sd = sd(infper)) 

#Take a look
summary(reg.infper_site)
```

Make a plot showing transect and site level estimates of infection perimeter.
```{r}
#Create a variable in each df that identifies whether its a site or transect
#level estimate
reg.infper_tran$meas_lev <- "Transect estimate"
reg.infper_site$meas_lev <- "Site mean"

#Join them
head(reg.infper_tran); head(reg.infper_site)
x <- reg.infper_tran %>% 
  select(site_id, infper, meas_lev)
x1 <- reg.infper_site %>% 
  select(site_id, infper_mean, meas_lev) %>% 
  rename(infper = infper_mean)
x2 <- rbind(x, x1)

#Set order of measurment level variable
x2 <- x2 %>% 
  mutate(meas_lev = factor(meas_lev, levels = c("Transect estimate", "Site mean")))

#Colours
colors_infper <- c("#FD8D3C", "darkred")

#Plot
p <- ggplot(x2, aes(x = infper, y = site_id, colour = meas_lev,
                    shape = meas_lev)) +
  geom_point() +
  theme_classic() +
  scale_color_manual(values = colors_infper) +
  labs(x = "Infection perimeter (m)",
       y = "Site",
       color = "Measurement level",
       shape = "Measurement level") +
  theme(axis.text = element_text(size = 11, 
                                   family = "Times New Roman"),
        strip.text = element_text(size = 11, family = "Times New Roman"), 
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                    face = "bold"),
        legend.position = "top")
p

#Export
# ggsave(here("./figures/reg_inf_per.svg"), plot = p, device = "svg",
#        width = 20, height = 15, units = "cm")
```

Outer live infected tree at each site. 
```{r}
#Don't need to filter out simulated trees because all simulated Hw are 
#uninfected.
reg.out_inf <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & spp == "Hw" & status %in% live_stat &
           hdm_pa == "Y") %>% 
  group_by(site_id) %>% 
  summarise(out_inf_dist = max(dist_y_h)) 

#Take a look
summary(reg.out_inf)
```

###Vertical infection distribution
We also want to summarize how infection is distributed in the tree. E.g. if its
a DMR 1, then we want to know whether the 1 is in the bottom, middle or upper 
crown. Do this for live Hw trees that have a DMR of >=1. The basic 
strategy is going to be to break down each tree level DMR (possible values for 
infected tree of 1-6) by the contributions of each crown third. 
```{r}
#Start by creating subsetting the dataframe to just DMR ratings (for the whole 
#tree and for the crown thirds).
reg.vpos <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & spp == "Hw" & status %in% live_stat &
           hdm_pa == "Y" & dmr >= 1) %>% 
  select(tree_id, site_id, crown_class_2, dmr, dmr_l, dmr_m, dmr_u)

#Divide each crown third rating by the total DMR to get the crown third 
#contribution
reg.vpos <- reg.vpos %>% 
  mutate(cont_l = dmr_l/dmr,
         cont_m = dmr_m/dmr,
         cont_u = dmr_u/dmr)

#Lengthen so that crown third contributions are a single column
reg.vpos <- reg.vpos %>% 
  select(-c(dmr_l, dmr_m, dmr_u)) %>% 
  pivot_longer(cols = starts_with("cont"),
               values_to = "cont",
               names_to = "ct",
               names_prefix = "cont_")

#Summarize this for each crown class. This creates groups for every unique
#crown class - dmr -crown third combination. Within each group, it takes each
#row and averages the contribution value for each crown third. 
reg.vpos <- reg.vpos %>% 
  group_by(crown_class_2, dmr, ct) %>% 
  summarise(cont = mean(cont),
            n_tree = n())
```

Graph this distribution
```{r}
#We will use the n_tree column to label the plot with how many trees there are 
#for each crown class-dmr combination, but right now there are three values for
#every combination because the dataframe is also subset by crown third. We just
#need one
reg.vpos <- reg.vpos %>% 
  mutate(n_tree = if_else(ct == "l", n_tree, NA))

#Reorder crown third and crown class as factors for plotting
reg.vpos <- reg.vpos %>% 
  mutate(ct = case_match(ct, 
                         "l" ~ "lower",
                         "m" ~ "middle",
                         "u" ~ "upper"),
         crown_class_2= case_match(crown_class_2,
                                   "C" ~ "Dominant/codominant",
                                   "I" ~ "Intermediate",
                                   "S" ~ "Suppressed")) %>% 
  mutate(ct = factor(ct, levels = c("upper", "middle", "lower")),
         crown_class_2 = factor(crown_class_2, c("Dominant/codominant", 
                                             "Intermediate", 
                                             "Suppressed")))

p <- ggplot(reg.vpos, aes(x = dmr, y = cont, fill = ct)) + 
  geom_bar(stat = "identity", position = "stack") + 
  geom_text(aes(label = n_tree), y = 1, vjust = -0.5,
            family = "Times New Roman") +
  facet_wrap(~crown_class_2, ncol = 3) +
  theme_classic() + 
  scale_y_continuous(limits = c(0, 1.1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  scale_fill_manual(values = colors_ct) + 
  theme(legend.position = "right",
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 11, family = "Times New Roman",
                                    face = "bold"),
        legend.text = element_text(size = 11, family = "Times New Roman"),
        axis.text = element_text(size = 10, family = "Times New Roman"),
        axis.title = element_text(size = 11, family = "Times New Roman",
                                  face = "bold"),
        strip.text = element_text(size = 11, family = "Times New Roman",
                                  margin = margin(0.05, 0.05, 
                                                  0.05, 0.05, "cm"))) + 
  labs(x = "DMR", 
       y = "Mean crown third contribution", 
       fill = "Crown third")
p
#Export this plot
# ggsave(here("./figures/reg_vdist_inf.svg"), plot = p, device = "svg",
#        width = 6.5, height = 4, units = "in")
```

##Export tables
Save the tables created in this section. 
```{r}
#Table with all of the regen infection stats
# write_csv(reg_i_all, "./tables/reg_inf_hw_all.csv")

#Table with broken down by interval and crown class for thesis
# write_csv(reg_i_live, here("./tables/reg_inf_hw_live.csv"))
```

##Amabalis fir, ph2 regen 0-15m
Generate some summary stats to report on infection in Amabalis fir at the ph_2
site, mirroring the stats created for the mature component. Use the 0-15m 
interval. 

Stats:
  -Site basal area/ha
  -Site trees/ha
  -Af/Hw basal area/ha
  -Af/Hw trees/ha
  -Percent of site basal area made up of Af/Hw
  -Percent of site stems made up of Af/Hw
  -Incidence of infection in live Af/Hw trees
  -Af/Hw average DMR
  -Af/Hw DMI

Note: for clarity, Amabilis fir two letter code is Ba. But to avoid confusion 
with basal area, it is abbreviated with af (except when 
the code is calling the species code in the data). 
```{r}
#How many trees are we talking about
reg.af <- regen_15 %>% filter(spp == "Ba")
nrow(reg.af) #17 trees
unique(reg.af$site_id) #only at ph_2

#Generate some summary stats:
ph2.reg15 <- regen_15 %>% 
  filter(site_id == "ph_2") %>% 
  summarise(nstem_ha = sum(phf_site),
            af_nstem_ha = sum(phf_site[spp == "Ba"]),
            hw_nstem_ha = sum(phf_site[spp == "Hw"]),
            ba_m2_ha = sum(ba_m2_ph),
            af_ba_m2_ha = sum(ba_m2_ph[spp == "Ba"]),
            hw_ba_m2_ha = sum(ba_m2_ph[spp == "Hw"]),
            l_af_nstem_ha = sum(phf_site[status %in% live_stat & spp == "Ba"]),
            l_hw_nstem_ha = sum(phf_site[status %in% live_stat & spp == "Hw"]),
            li_af_nstem_ha = sum(phf_site[status %in% live_stat &
                                            spp == "Ba" & hdm_pa == "Y"]),
            li_hw_nstem_ha = sum(phf_site[status %in% live_stat & 
                                            spp == "Hw" & hdm_pa == "Y"]),
            s.af_dmr = mean(dmr[status %in% live_stat & spp == "Ba"]),
            s.hw_dmr = mean(dmr[status %in% live_stat & spp == "Hw"]),
            s.af_dmi = mean(dmr[status %in% live_stat & spp == "Ba" & 
                                  dmr >= 1]),
            s.hw_dmi = mean(dmr[status %in% live_stat & spp == "Hw" & 
                                  dmr >= 1])) %>% 
  mutate(p_nstem_af = 100*af_nstem_ha/nstem_ha,
         p_nstem_hw = 100*hw_nstem_ha/nstem_ha,
         p_ba_af = 100*af_ba_m2_ha/ba_m2_ha,
         p_ba_hw = 100*hw_ba_m2_ha/ba_m2_ha,
         p_l_af_nstem_inf = 100*li_af_nstem_ha/l_af_nstem_ha,
         p_l_hw_nstem_inf = 100*li_hw_nstem_ha/l_hw_nstem_ha)

#Compare with Hw at site
##What is site total nstem_ha and ba_ha
ph2.reg15 %>% select(nstem_ha, ba_m2_ha)

##How much of the site nstem_ha and ba_ha are made of of Hw and Ba?
###The two spp are pretty similar
ph2.reg15 %>% select(p_nstem_af, p_nstem_hw, p_ba_af, p_ba_hw)

##What % of live Hw and Ba at each site are infected?
###Infection rates higher in Hw
ph2.reg15 %>% select(p_l_af_nstem_inf, p_l_hw_nstem_inf)

#What is the mean DMR and DMI of Hw and Ba?
###Infection more severe in Hw than Ba
ph2.reg15 %>% select(s.af_dmr, s.hw_dmr, s.af_dmi, s.hw_dmi)
```