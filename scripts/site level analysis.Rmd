---
title: "Site Level Analyses"
author: "Hanno Southam"
date: "`r Sys.Date()`"
output: html_document
---
UPDATED: 13 Nov 2024
##############
READ ME
This script compares the 11 HDM study sites to eachother. 

Section 1 compares the different site climates, using data from Climate BC 
(https://climatebc.ca/mapVersion) and Barrett et al. (2012) as a framework for 
selecting and interpreting variables. 

Section 2 compares the size and composition of trees in the regen and mature 
components between sites. 

Section 3 compares HDM infection in the mature component between sites to get a 
high-level understanding if the infection sources are similar between sites. 

Section 4 compares HDM infection in the regen component between sites. 

Summary tables and figures are created in each section for writing and 
downstream analyses. The primary starting object for the script is the output
of the 'seed load.Rmd' script (trees_sl.csv). 

References
Barrett, T. M., Latta, G., Hennon, P. E., Eskelson, B. N. I., & Temesgen, H. (2012). Host–parasite distributions under changing climate: Tsuga heterophylla and Arceuthobium tsugense in Alaska. Canadian Journal of Forest Research, 42(4), 642–656. https://doi.org/10.1139/x2012-016
##############

#Load packages
```{r}
library(tidyverse)
library(here)
library(RColorBrewer)
library(ggrepel)
library(patchwork)
```

#Prep
##Load and format data
Read in and format the various datasets from the HDM sites
```{r}
rm(list=ls(all=TRUE))

##Dataset 1: site data. 
#This contains variables at the site level. The key pieces for analysis are: 
#year harvested and CWH subzone
site <- read_csv(here("data/cleaned/site data.csv"))
str(site)
summary(site)

#Order by site_id, used to seeing it in this order
site <- arrange(site, site_id)

#Create some variables to use in summary tables and figures
#Convert date_surveyed to date format
site <- site %>% rename(date_sur_char = date_surveyed) %>% 
  mutate(date_sur = dmy(date_sur_char)) %>% 
  relocate(date_sur, .after = date_sur_char)

#Extract year
site <- site %>% mutate(yr_sur = year(date_sur))
#Recalculate age column
site <- site %>% mutate(age = yr_sur - yr_har)
site$age #luckily, got pretty good spread

#Create a single variable from all the pieces of a BEC zone
site <- site %>% 
  unite(col = bec, sep = "", c("bec_z", "bec_sz", "bec_var"), remove = FALSE)

#Create a variable that combines site_id, bec, and regen age 
site <- site %>% unite(col = id_bec_age_f, sep = ", ", 
                       c("site_id", "bec", "age"), 
                       remove = FALSE) %>% 
  mutate(id_bec_age_f = factor(id_bec_age_f)) %>% 
  relocate(id_bec_age_f, .after = site_id)

#Make cluster, bec and id_bec_age_f factors
site <- site %>% mutate(across(c(cluster, bec, id_bec_age_f), ~as.factor(.)))
str(site)


#Dataset 2: transect data
#This describes the transects extending from the edge line into the regen
#component. There are three transects per site. Within a site, all transects
#are intended to be the same length; there were a couple exceptions (due to
#incorrect layout and one transect being extended to traverse a blowdown 
#patch). The length measured across all variables within a site is recorded 
#in the tr_leng_s variable. 
tran <- read_csv(here("./data/cleaned/transect data_c.csv"))
head(tran)
str(tran)


##Dataset 3: tree data
#This contains data for each measured tree (mature and regen trees)
#Using trees_sl object, which is the last trees object in the workflow
#Treats assessed_by var as a logical for some reason and throws up an error. 
#Not a problem and not going to use this var
trees <- read_csv("data/workflow/trees_sl.csv")
str(trees)
summary(trees)

#Convert factor vars to factors: 
trees <- trees %>% mutate(across(
  c(site_id, spp, status, hdm_pa, b_lc, 
    broom_pa, broom_pos, stem_pa, crown_class, crown_cond, outside_10, assessed_by, tree_type, dmr_f),
  ~as.factor(.)))

#Convert plot_id and dmrs to integers
trees <- trees %>% mutate(across(
  c(plot_id, dmr_l, dmr_m, dmr_u, dmr), ~as.integer(.)))

str(trees)

#Create new factor dmr variable that has fewer levels and ascends logically from healthy to most infected
levels(trees$dmr_f)
trees <- trees %>% 
  mutate(dmr_f2 = case_when((dmr_f =="1" | dmr_f=="2") ~ "1-2", 
                            (dmr_f =="3" | dmr_f=="4") ~ "3-4", 
                            (dmr_f =="5" | dmr_f=="6") ~ "5-6", 
                            .default = dmr_f))
trees <- trees %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("-", "DU", "0","IBLC", 
                                            "1-2", "3-4", "5-6", "DI")))
summary(trees$dmr_f2)

#Create new spp variable that sets all spp that aren't major species to "other"
maj_spp <- c("Hw", "Cw", "Fd", "Ba")
trees <- trees %>% 
  mutate(spp2 = if_else(spp %in% maj_spp, spp, "other")) %>% 
  mutate(spp2 = factor(spp2, levels = c("Hw", "Ba", "Cw", "Fd", "other")))

#Join some site level variables to tree data: 
trees <- left_join(trees, select(site, cluster, bec, 
                                 id_bec_age_f, age, site_id), by="site_id")

#Join identical transect length measured at each site to tree data
trees <- left_join(trees, select(tran, transect_id, tr_leng_s),
                   by = join_by("plot_id" == "transect_id"))
```

##Subset data to objects for different comparisons
There are a couple things we need to consider to ensure we are making fair 
comparisons throughout this script: 
(1) At a few sites we mapped mature trees up to 15m from the edge, when the 
standard was 10m.
(2) Regen transects are variable length. When making any comparison of two 
sites need to ensure we are comparing data from equivalent transect lengths. 
(3) At two sites (mi_1) and (mk_3) the transect length within a site varied.
When calculating site level metrics we will need to consider this too. 

Deal with the first of these right off the bat by removing mature trees >10m 
from the edge. 
```{r}
trees <- trees %>% filter(outside_10 =="N" | is.na(outside_10))
```

Calculate basal area (m^2) from dbhg. We will use this throughout the rest of 
the script
https://en.wikipedia.org/wiki/Basal_area
```{r}
trees <- trees %>% mutate(ba_m2 = pi*((dbh/100)/2)^2)
```

Break apart the dataset into different components. At the highest level, 
separate mature and regen components. Then within regen components, separate
out a dataset of trees <=15m from the edge and one of trees <=50m from the edge.
The minimum transect length was 15m, so all sites have data for 0-15m; this 
subset will be used to compare size an composition across sites and also for
HDM infection summaries within the zone of influence of the mature component. 
The dataset from 0-50m will include simulated trees to a different extent for
different sites; it will be used to provide HDM infection summaries over a 
larger range. 

A binned version of dbh is also created here for plotting to avoid creating it
multipe times when the objects are split apart. 
```{r}
#Subdivide data into mature and regen components
mature <- trees %>% filter(tree_type=="mature") 
regen <- trees %>% filter(tree_type == "regen") 

#Create bins of diameter classes from dbh
##Default is for intervals to be half-open. They include the upper bound but not the lower bound. e.g. (10,20] includes 20 but (20, 30] does not
## https://stackoverflow.com/questions/41304960/how-to-create-breaks-using-the-cut-function-without-numbers-overlapping
#Create a smaller bin for regen trees and a larger one for mature trees 
range(mature$dbh)
mature <- mature %>% 
  mutate(dbh_bin2 = cut(dbh, breaks = c(9, 15, 25, 35, 45, 55, 65, 75, 85,
                                       95, 105, 115, 125, 135, 145, 155,
                                       165, 175, 185, 195, 205, 300),
                       include.lowest = TRUE))

range(regen$dbh)
regen <- regen %>% 
  mutate(dbh_bin = cut(dbh, breaks = c(4, 10, 15, 20, 25, 30, 35, 40, 45,
                                       50, 55, 60, 65, 70, 75, 80,
                                       85, 90, 95, 100, 105, 110, 115, 120,
                                       125, 130, 135, 140, 145, 150, 155, 
                                       160, 165, 170, 175, 180, 185, 190, 
                                       195, 200, 300),
                       include.lowest = TRUE))

#Split regen object into datasets of <=15m and <=50m from edge
regen_15 <- regen %>% filter(dist_y_h <= 15)
regen_50 <- regen %>% filter(dist_y_h <= 50)
```

Create a conversion factor to represent trees on a per hectare basis. The 
comparisons in this script are at the site level, so this factor should 
represent each tree's contribution to the total area surveyed at a site; for 
mature trees, this is simple because there were no subunits but for regen trees
we need to pool the three transects. 
- Mature component footprint = 55x10m =550m2=0.055ha
- Regen transect footprint = # transects* transect length (15 or 50m) x 
5m = xx m2 = xx ha
```{r}
mature <- mature %>% mutate(phf_site = 1/(55*10/10000))
regen_15 <- regen_15 %>% mutate(phf_site = 1/(3*15*5/10000))
regen_50 <- regen_50 %>% mutate(phf_site = 1/(3*50*5/10000))
```

##Plotting colours
Define some consistent colours to plot with
```{r}
display.brewer.all(colorblindFriendly = TRUE)
?brewer.pal()

#Different site clusters
colors_clust <- c("dodgerblue", "dodgerblue4", "cadetblue2", "cadetblue4")

#spp colours Ba, Cw, Fd, Hw, other
#Make Hw blue so it matches below
levels(trees$spp2)
#Get names of colours
brewer.pal(5, "Paired")
#Define the palette so Hw is blue
colors_spp <- c("#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99")

#hdm_pa colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$hdm_pa)
#Reorder factor so that healthy trees are plotted on the bottom
trees$hdm_pa <- fct_relevel(trees$hdm_pa, "Y", "U", "N", "-")
colors_hdm_pa <- c("goldenrod1", "grey", "#A6CEE3")

#dmr_f2 colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$dmr_f2)
colors_dmr_f2 = c("#1F78B4", "#A6CEE3", brewer.pal(4, "Oranges"), "hotpink")

#Crown third colours
colors_ct <- c("khaki1", "khaki3", "khaki4")
```

#SECTION 1: Site climate comparisons
Goal of this section is to descriptively describe differences in climate and 
physical (slope, aspect,elevation) between sites. The cliamte variables are 
ones with a conceptual link to HDM biology -- see Barrett et al. (2012). 
```{r}
####Read in climate data
#Data downloaded from ClimateBC (https://climatebc.ca/mapVersion, 24 Jun 2024). ClimateBCv7.50. Period: Normal_1991_2020
#Exception: cr_3 site, surveyed 17 Jul 2024, downloaded data 25 Aug 2024
climate <- read_csv('./data/raw/hdm_climdata.csv') #raw data from climateBC

####Check coordinates were inputted correctly, then join site_ids 
#Sites are identified by coordinates in the climate dataset. Check they are right before joining site_ids
site <- site %>% mutate(dd_X_r = round(dd_X, digits = 4), #round number of decimals to match climateBC rounding
                        dd_Y_r = round(dd_Y, digits = 5))
x <- site$dd_X_r - climate$long
y <- site$dd_Y_r - climate$Lat
print(x); print(y)
#Good, almost al 0s, just one that is different by 1 x 10e-4 (a rounding error)

#Join site_id, bec and cluster by latitude values
climate <- left_join(climate, select(site, site_id, cluster, bec, dd_Y_r), by = c("Lat" = "dd_Y_r"))

#move site_id to the front
climate <- climate %>% select(site_id, cluster, bec, everything())

#Define climate variables that were in Bianca's paper
#Descriptions of these variables and whether they are exact matches or approximiations of variables used in paper are in: /Users/hannosoutham/Library/CloudStorage/OneDrive-UBC(1)/Msc/Thesis/ch1.docx

#1 Growing degree days
climate <- climate %>% rowwise() %>% mutate(DD5_gs = sum(c_across(DD5_sp:DD5_at)))
select(climate, DD5, DD5_gs)

#2 Growing season radians
climate <- climate %>% rowwise() %>% mutate(Rad_gs = mean(c_across(Rad_sp:Rad_at)))
select(climate, MAR, Rad_gs)

#3 Lowest average minimum monthly temperature (Tmin_wt)
# find lowest Tmin value across all months
climate <- climate %>% rowwise() %>% mutate(Tmin_all = min(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_wt, Tmin_all)

#4 Standard deviation of lowest average minimum monthly temperature  
# calculate the standard deviation in Tmin across all of the months
climate <- climate %>% rowwise() %>% mutate(Tmin_sd = sd(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_sd)

#5 Snow (PAS) 
select(climate, MAP, PAS)

#6 Rain
climate <- climate %>% mutate(PAR = MAP-PAS)
select(climate, MAP, PAR, PAS)

#7 Lowest average spring monthly temperature
# Find lowest Tmin value between May and June
climate <- climate %>% rowwise() %>% mutate(Tmin_mj = min(c_across(Tmin_05:Tmin_06)))
select(climate, Tmin_mj)

#8 Lowest average fall monthly temperature (Tmin_at)
# Find the lowest Tmin value between August and September
climate <- climate %>% rowwise() %>% mutate(Tmin_as = min(c_across(Tmin_08:Tmin_09)))
select(climate, Tmin_as)

#Filter table to just the variables we are interested in and some others that
#are good general descriptors (MAT, TD, MAP)
climate <- climate %>% 
  select(site_id, cluster, bec, MAT, TD, MAP, PAR, PAS, DD5_gs, Rad_gs, 
         Tmin_all, Tmin_sd, Tmin_mj, Tmin_as) 

####Graph this
#Define levels of bec zone in an order that corresponds to wettest to driest
levels(climate$bec)
climate <- climate %>% 
  mutate(bec = factor(bec, levels = c("CWHvm2", "CWHvm1", "CWHdm-", "CWHxm2")))

#Create a long dataframe so a variables can be plotted in one go
clim_g <- climate %>%
  pivot_longer(MAT:Tmin_as, names_to = "climvar", values_to = "climval")

#Create a new colum with variable names and units
unique(clim_g$climvar)
clim_g <- clim_g %>% 
  mutate(climvar2 = case_match(climvar,
                               "MAT" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "TD" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "MAP" ~ paste0(climvar, " (mm)"),
                               "PAR" ~ paste0(climvar, " (mm)"),
                               "PAS" ~ paste0(climvar, " (mm)"),
                               "DD5_gs" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "Rad_gs" ~ paste0(climvar, " (MJ m", 
                                                 "-2", " d", 
                                                 "-1", ")"),
                               "Tmin_all" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_sd" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_mj" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_as" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)")
                               )) %>% 
  mutate(climvar2 = factor(climvar2, levels = c("MAT (°C)", "TD (°C)", 
                                                "Tmin_all (°C)", "Tmin_sd (°C)",
                                                "Tmin_as (°C)", "Tmin_mj (°C)",
                                                "Rad_gs (MJ m-2 d-1)",
                                                "DD5_gs (°C)",
                                                "MAP (mm)", "PAR (mm)", 
                                                "PAS (mm)")))
unique(clim_g$climvar2)

#Create a plot
p <- ggplot(clim_g, aes(x=bec, y=climval, label=site_id, color = cluster)) +
  geom_text_repel(size = 2) +
  geom_point() +
  facet_wrap(~climvar2, scales = "free_y") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1, vjust = 0.5),
        legend.position = "inside",
        legend.position.inside = c(0.88,0.05),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 14),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  labs(x = "BEC", 
       y = "Climate variable value",
       colour = "Site cluster") +
  scale_color_manual(values = colors_clust)
p

#Export this plot
pdf(here("./figures/climate_vars.pdf"), width = 11, height = 8.5)
p
dev.off()
```

##Assemble output tables
Build clean tables combining physical and climate variables. We will 
create two: a large one with site id, cluster, elevation, slope, aspect, 
BEC zone and all the climate variables that we can use in other downstream 
analyses and two create tables I didn't think of in the future and a smaller 
one for thesis that omits the cliamte variables.

Start by out climate variables described above. Also include MAT (mean annual 
temperature), TD (temperature difference betweenmean coldest month temperature 
and mean warmest month temperature) and MAP (mean annual precipitation) because 
they are good descriptors
```{r}
climate2 <- climate %>% 
  select(site_id, cluster, bec, MAT, TD, MAP, PAR, PAS, DD5_gs, Rad_gs, 
         Tmin_all, Tmin_sd, Tmin_mj, Tmin_as) 
```

Then add physical variables. Slope is a bit tricky here. There are two sets of 
slopes, slopes for the transect and slopes for the fall line. For both of those
sets we measured slope at multiple places to capture changes in slope profile.
For the purpose of creating a descriptive table of site characteristics for 
writing, we will select the measurement that capture the general fall line 
slope of the regen component. Need to reference the notes in the csv to know
which ones to pick here. 
```{r}
#Add elevation
climate2$elevation <- site$elevation

#Subset transect data to slope variables
slope <- tran %>% select(site_id, transect_id, starts_with("fl"))

#Add declination
x <- site %>% select(site_id, Dec)
slope <- left_join(slope, x, by = "site_id")

#Two slopes were taken for fall line only at two sites (cr_1 and cr_2). Both
#cases were places where the mature component sloped into a creek. The first 
#measurement captured the bank down to the creek, the second captured the 
#profile in the regen. We want the second. 
slope <- slope %>% 
  mutate(reg_sl = if_else(!is.na(fl_sl2), fl_sl2, fl_sl1),
         reg_az = if_else(!is.na(fl_az2), fl_az2, fl_az1)
         )

#Then correct for declination for fall line azimuth measurements taken with the
#rangefinder. One case where suspected error (recorded as compass but should
#have been rangefinder); fix that.
slope <- slope %>% 
  mutate(fl_az_device = case_when(transect_id == 102 ~ "rangefinder",
                                  .default = fl_az_device))
slope <- slope %>% 
  mutate(reg_az_corr = case_match(fl_az_device,
                                  "compass" ~ reg_az,
                                  "rangefinder" ~ ((reg_az) + Dec)%%360))

#Summarize these by site (take mean)
slope <- slope %>% 
  group_by(site_id) %>% 
  summarise(reg_az = round(mean(reg_az), 1),
            reg_sl = round(mean(reg_sl), 1))

#Join these to the table
climate2 <- left_join(climate2, slope, by = "site_id")
```

Export the tables. 
```{r}
#Subset a table for thesis
climate3 <- climate2 %>% select(site_id, cluster,
                                bec, elevation, reg_az, reg_sl)

#Export
# write_csv(climate2, "./tables/site_climphys_big.csv")
# write_csv(climate3, "./tables/site_climphys_small.csv")
```

#SECTION 2: Size class distribution and species composition
Here I compare the composition and size class distribution of the trees 
between sites. We will use the 'regen_15' object for the regen component
because that is object contains only measured trees; it will be free from any
bias created by simulating trees. As a general principle, usually two versions
of each metric are created, one on a raw basis and one on a perhectare basis. 
```{r}
#Create a couple of dataframes to append results to
reg_cs <- site %>% select(site_id)
mat_cs <- site %>% select(site_id)
```

##Basal area, stem density
Start by basic site level metrics: basal area, number of stems. 
```{r}
#Regen
reg.ba_nstem <- regen_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2 = sum(ba_m2),
         reg.nstem = n(),
         reg.ba_m2_ha = sum(ba_m2*phf_site),
         reg.nstem_ha = sum(phf_site))

#Mature
mat.ba_nstem <- mature %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2 = sum(ba_m2),
         mat.nstem = n(),
         mat.ba_m2_ha = sum(ba_m2*phf_site, na.rm = TRUE),
         mat.nstem_ha = sum(phf_site, na.rm = TRUE))

#Join these to results table
reg_cs <- left_join(reg_cs, reg.ba_nstem, by="site_id")
mat_cs <- left_join(mat_cs, mat.ba_nstem, by="site_id")

#Print a summary table, see how they compare:
reg_cs %>% select(site_id, reg.ba_m2:reg.nstem_ha) %>% 
  arrange(reg.ba_m2_ha)
mat_cs %>% select(site_id, mat.ba_m2:mat.nstem_ha) %>% 
  arrange(mat.ba_m2_ha)
```

##DBH, codominant tree layer
Next, summarize the dbh of the codominant/dominant trees at each site. Do it 
across all species and then for hemlock. 
```{r}
#Regen
reg.dbh <- regen_15 %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C") %>% 
  summarise(reg.dbh_mean_cd_all = mean(dbh, na.rm = T),
            reg.dbh_sd_cd_all = sd(dbh, na.rm = T),
            reg.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            reg.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Mature
mat.dbh <- mature %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C") %>% 
  summarise(mat.dbh_mean_cd_all = mean(dbh, na.rm = T),
            mat.dbh_sd_cd_all = sd(dbh, na.rm = T),
            mat.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            mat.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Join these back to the results dataframes
reg_cs <- left_join(reg_cs, reg.dbh, by="site_id")
mat_cs <- left_join(mat_cs, mat.dbh, by="site_id")

#Take a look at them
reg_cs %>% select(site_id, contains("dbh")) %>% arrange(reg.dbh_mean_cd_all)
mat_cs %>% select(site_id, contains("dbh")) %>% arrange(mat.dbh_mean_cd_all)
```

##Percent makeup of Hw
Here, calculate how much of the basal area and stems at a site are made up of 
Hw. These are useful summary stats and tell us about host avaialbility across
the sites. 
```{r}
##Regen
reg.ba_nstem_hw <- regen_15 %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>%
  summarise(reg.ba_m2_hw = sum(ba_m2),
            reg.nstem_hw = n())
  
#Add to results dataframe
reg_cs <- left_join(reg_cs, reg.ba_nstem_hw, by="site_id")

#Calculate proportion of total basal area and stems made up of hw
reg_cs <- reg_cs %>% 
  mutate(reg.p_ba_hw = reg.ba_m2_hw/reg.ba_m2,
         reg.p_stem_hw = reg.nstem_hw/reg.nstem)

##Mature
mat.ba_nstem_hw <- mature %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2_hw = sum(ba_m2),
            mat.nstem_hw = n())

##Add to results dataframe
mat_cs <- left_join(mat_cs, mat.ba_nstem_hw, by="site_id")
mat_cs <- mat_cs %>% 
  mutate(mat.p_ba_hw = mat.ba_m2_hw/mat.ba_m2,
         mat.p_stem_hw = mat.nstem_hw/mat.nstem)

##Print a summary table. 
#Hw makes up between 11 and 95% in regen and between 10% and 97% in mature 
#component. Two Ucluelet sites (ph_2 and ph_3) are outliers, with low 
#Hw percentages. Spread of Hw percentage more continuous in mature; 
#in regen, most sites have >70% Hw and only ph_2 and ph_3 are <50%. 
reg_cs %>% 
  select(site_id, reg.ba_m2, reg.ba_m2_hw, reg.p_ba_hw) %>% 
  arrange(reg.ba_m2)
mat_cs %>% select(site_id, mat.ba_m2, mat.ba_m2_hw, mat.p_ba_hw) %>% 
  arrange(mat.ba_m2)
```

##Basal area and stem density by species and diameter class
Break down basal area and stem density by species and diameter class. We can 
use this to create some graphs that summarize the tree composition at a site.
```{r}
#Do the breakdwon. A bit of a messy table, but graphed below
reg.struc <- regen_15 %>% group_by(site_id, spp, dbh_bin) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin, fill=list(ba_m2=0, nstem=0)) #add 0s in places there was no trees
mat.struc <- mature %>% group_by(site_id, spp, dbh_bin2) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin2, fill=list(ba_m2=0, nstem=0))#add 0s in places there was no trees

#Graph the species composition. See that Hw, Fd, Cw and Ba are major species
ggplot(reg.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
ggplot(mat.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
```

The major species at the sites are: Hw, Fd, Cw and Ba. We created a second
version of the species variable above that groups everything else as 'other'. 
Do the breakdown again and use this second species variable. Then use the 
breakdown to generate some plots, showing species composition across the sites. 
```{r}
#Summarize ba and nstems by species and diameter class again
#This time use spp2, which lists all non major spp as other
reg.struc <- regen_15 %>% 
  group_by(site_id, spp2, dbh_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin, fill=list(ba_m2_ha=0, nstem_ha=0)) #add 0s in places there was no trees

mat.struc <- mature %>% 
  group_by(site_id, spp2, dbh_bin2) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha=0, nstem_ha=0))#add 0s in places there was no trees

#Regen
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
reg.struc <- reg.struc %>% filter(ba_m2_ha>0) 

#PLOT. 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(reg.struc, aes(x=dbh_bin, y=nstem_ha, fill=spp2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")
p

#Export this plot
# pdf(here("./figures/reg_comp.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(reg.struc, aes(x=dbh_bin, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  

##Mature
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.struc <- mat.struc %>% filter(ba_m2_ha>0) #Remove rows with 0 because R will plot all dbh intervals (up to 180cm)

#PLOT 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(mat.struc, aes(x=dbh_bin2, y=nstem_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) +  
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 13),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")  
p

#Export this plot
# pdf(here("./figures/mat_comp.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(mat.struc, aes(x=dbh_bin2, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  
```

##Summary table for thesis
We need to assemble a summary table for 'the thesis' that generally describes
the forest at the sites. It should contain: 
- site_id, 
- years since harvest 
- mature forest age estimates 
- stem density (and proportion of Hw) 
- basal area (and propotion of Hw)
- mean and sd of dbh of all trees 
- mean and sd of dbh for Hw
- height estimate of C/D Hw
- mature-regen height difference
- site history

Start with stuff that is already in the site table. 
```{r}
#Start with a skeleton table
cs_sum <- site %>% select(site_id, age, site_history) %>% 
  rename(yr_since_har = age)
```

Mature forest age estimates ar in the vri dataframe. Load that. At some sites
multiple vri polygons overlap the mature component. In those instances, 
use the average age estimate. 
```{r}
vri <- read_csv(here("./data/cleaned/vri_c.csv"))

#Subset to polygons representing mature components
mat.age <- vri %>% filter(tree_type == "mature")
nrow(mat.age)

#Estimated age of Hw in the layer 1 trees is in the AGE_HW column. Get average.
mat.age <- mat.age %>% 
  group_by(site_id) %>% 
  summarise(mat.age_hw = mean(AGE_HW, na.rm = T))

#Join these to the summary table
cs_sum$mat.age_hw <- mat.age$mat.age_hw 
cs_sum <- cs_sum %>% 
  relocate(mat.age_hw, .after = "yr_since_har")
```

Height estimates of the codominant/dominant Hw at each site are in the crown
volume dataset. Load that and calcualte the height difference. 
```{r}
cv <- read_csv(here("./data/workflow/crown_vol.csv"))

#Filter to co dominant/dominant layer
unique(cv$crown_class_2)
ht_cd <- cv %>% 
  filter(crown_class_2 == "C")

#Select just the relevant columns
ht_cd <- ht_cd %>% 
  select(site_id, tree_type, height_cv_est)

#Widen so that mature and regen heights are in separate columns
ht_cd <- pivot_wider(ht_cd, names_from = tree_type, 
                       values_from = height_cv_est) %>% 
  rename(reg.ht_cd_hw = regen, 
         mat.ht_cd_hw = mature)

#Calculate height difference 
ht_cd <- ht_cd %>% 
  mutate(ht_diff_cd_hw = mat.ht_cd_hw - reg.ht_cd_hw)

#Join this to the summary dataframe
cs_sum <- left_join(cs_sum, ht_cd, by = "site_id")

#Round the columns to one decimal
cs_sum <- cs_sum %>% 
  mutate(across(c(reg.ht_cd_hw, mat.ht_cd_hw, ht_diff_cd_hw), ~ round(., 1)))
```

To complete the job add the composition and dbh stats we created in this 
section. 
```{r}
#Add stem density and proportion of stem that are Hw
cs_sum <- cs_sum %>% 
  mutate(reg.nstem_ha = reg_cs$reg.nstem_ha,
         mat.nstem_ha = mat_cs$mat.nstem_ha,
         reg.p_stem_hw = reg_cs$reg.p_stem_hw,
         mat.p_stem_hw = mat_cs$mat.p_stem_hw) %>% 
  mutate(across(c(reg.nstem_ha, mat.nstem_ha), ~round(., 0)),
         across(c(reg.p_stem_hw, mat.p_stem_hw), ~round(., 2)),
         )

#Do the same but with basal area
cs_sum <- cs_sum %>% 
  mutate(reg.ba_m2_ha = reg_cs$reg.ba_m2_ha,
         mat.ba_m2_ha = mat_cs$mat.ba_m2_ha,
         reg.p_ba_hw = reg_cs$reg.p_ba_hw,
         mat.p_ba_hw = mat_cs$mat.p_ba_hw) %>% 
  mutate(across(c(reg.ba_m2_ha, mat.ba_m2_ha), ~round(., 0)),
         across(c(reg.p_ba_hw, mat.p_ba_hw), ~round(., 2)),
         )

#Then add dbh stats
cs_sum <- cs_sum %>% 
  mutate(reg.dbh_mean_cd_all = reg_cs$reg.dbh_mean_cd_all,
         mat.dbh_mean_cd_all = mat_cs$mat.dbh_mean_cd_all,
         reg.dbh_sd_cd_all = reg_cs$reg.dbh_sd_cd_all,
         mat.dbh_sd_cd_all = mat_cs$mat.dbh_sd_cd_all,
         reg.dbh_mean_cd_hw = reg_cs$reg.dbh_mean_cd_hw,
         mat.dbh_mean_cd_hw = mat_cs$mat.dbh_mean_cd_hw,
         reg.dbh_sd_cd_hw = reg_cs$reg.dbh_sd_cd_hw,
         mat.dbh_sd_cd_hw = mat_cs$mat.dbh_sd_cd_hw) %>% 
  mutate(across(reg.dbh_mean_cd_all:mat.dbh_sd_cd_hw, ~round(., 1)))


#Put site history at the end
cs_sum <- cs_sum %>% 
  relocate(site_history, .after = last_col())
```

It is neater to represent standard deviation in brackets after and estimate. 
The dbh columns here would benefit from that. Create new columns in that form. 
```{r}
cs_sum <- cs_sum %>% 
  mutate(reg.dbh_all = paste0(reg.dbh_mean_cd_all,
                              " (", reg.dbh_sd_cd_all, 
                              ")"),
         mat.dbh_all = paste0(mat.dbh_mean_cd_all,
                              " (", mat.dbh_sd_cd_all, 
                              ")"),
         reg.dbh_hw = paste0(reg.dbh_mean_cd_hw,
                              " (", reg.dbh_sd_cd_hw, 
                              ")"),
         mat.dbh_hw = paste0(mat.dbh_mean_cd_hw,
                              " (", mat.dbh_sd_cd_hw, 
                              ")"))
```


##Export tables
Export the summary table and the two tables that contain the composition and 
size stats for writing and other analyses. 
```{r}
#Export
# write_csv(cs_sum, here("./tables/comp_size_sum.csv"))
# write_csv(reg_cs, "./tables/reg_comp_size.csv")
# write_csv(mat_cs, "./tables/mat_comp_size.csv")
```

##Extra code
```{r}
# #Assemble mature and regen results into a single table for thesis
# #Bind the cols together
# comp_size <- bind_cols(reg_cs, select(mat_cs, -site_id))
# 
# #Pivot the table longer so every measured variable shared between the two 
# #two datasets is in one column
# comp_size <- comp_size %>% 
#   pivot_longer(cols = -site_id, names_to = c("tree_type", ".value"), names_sep = "\\.")
# comp_size <- comp_size %>% mutate(tree_type = case_when(tree_type == "reg" ~ "regen", #recode tree_type
#                                                         tree_type == "mat" ~ "mature"))
```

#SECTION 3: Compare infection levels in mature trees
We will do this using number of stems and basal area on a per hectare basis 
as metrics. Using both is useful because basal area captures biases in 
infection towards bigger or smaller trees. Generally we aretrying to assess 
whether the mature components are similar infection sources. 

Amabalis fir (Ba) is another HDM host that was a significant portion of the 
sites near Ucluelet. We will include it in the workflow here. 

Start by creating a dataframe to add results to and getting some basic metrics
of Hw and Ba. 
```{r}
#Create a dataframe to append results to
mat_infection <- mat_cs %>% 
  select(site_id,  mat.nstem_ha, mat.ba_m2_ha)

#Filter to just Hw and Ba trees because these are the only ones we are 
#considering "significant hosts"
mat.hwba <- mature %>% filter(spp %in% c("Hw", "Ba"))

#Calculate basal area and number of stems made up of these spp
mat.hwba_summary <- mat.hwba %>% 
  group_by(site_id) %>% 
  summarise(mat.hwba_nstem_ha = sum(phf_site), 
            mat.hwba_ba_m2_ha = sum (ba_m2*phf_site))

#Add summary stats back to site data
mat_infection <- left_join(mat_infection, mat.hwba_summary, by="site_id")
```

##BA and # stems by P/A of HDM
Start simple and calculate the basal area and number of infected trees at 
each site. 
```{r}
mat.inf <- mat.hwba %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(mat.inf_ba_m2_ha = sum(ba_m2*phf_site), 
            mat.inf_nstem_ha = sum(phf_site)) 

#Join variables back to working dataframe
mat_infection <- left_join(mat_infection, mat.inf, by="site_id") 

#Calculate the proportion total and Hw + Ba stems/BA infected
mat_infection <- mat_infection %>% 
  mutate(mat.p_ba_inf = mat.inf_ba_m2_ha/mat.ba_m2_ha,
         mat.p_nstem_inf = mat.inf_nstem_ha/mat.nstem_ha,
         mat.p_hwba_ba_inf = mat.inf_ba_m2_ha/mat.hwba_ba_m2_ha,
         mat.p_hwba_nstem_inf = mat.inf_nstem_ha/mat.hwba_nstem_ha) 
```

Take a look at the spread of infection across the sites by each metric. 
  - By basal area, range is 0.37 to 1.00  of Hw/Ba but most (9/11) sites >0.8
  - By number of stems, range is 0.31 to 1.00 of Hw/Ba but most sites 
  (8/11) >0.75
  - Mature components have different basal areas so its important to look at 
  the magnitude (not just proportion) infected trees
```{r}
#Summary table sorted by proportion of BA infected
mat_infection %>% select(site_id, mat.ba_m2_ha, mat.hwba_ba_m2_ha, 
                         mat.inf_ba_m2_ha, mat.p_ba_inf, mat.p_hwba_ba_inf) %>% 
  arrange(mat.p_hwba_ba_inf) 

#Summary table sorted by proportion of stems infected
mat_infection %>% select(site_id, mat.nstem_ha, mat.hwba_nstem_ha, 
                         mat.inf_nstem_ha, mat.p_hwba_nstem_inf) %>% 
  arrange(mat.p_hwba_nstem_inf) 
```

###Graph this breakdown
Break down Hw/Ba BA and # of stems by site, presence/absence of HDM and dbh 
class. This will provide a much more interpretable summary of how infection is 
distributed in the mature component. 
```{r}
mat.hdmpa_dbh <- mat.hwba %>% 
  group_by(site_id, hdm_pa, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Because there are no non-host trees, the hdm_pa will now only have 
#trees in three of the four levels
levels(mat.hdmpa_dbh$hdm_pa)
mat.hdmpa_dbh %>% group_by(hdm_pa) %>% summarise(n_tree = n())

#Recode the factor the get rid of the fourth level
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% 
  mutate(hdm_pa = as.character(hdm_pa)) %>% 
  mutate(hdm_pa = factor(hdm_pa, levels = c("N", "U", "Y")))
#Check the levels
levels(mat.hdmpa_dbh$hdm_pa)

#Remove rows with 0 because R will plot all dbh intervals (300cm)
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% filter(ba_m2_ha > 0)

#Plot. # of stems
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=hdm_pa)) +  
  theme_classic() +
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N"))
  
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=hdm_pa)) + 
  theme_classic() +
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N")) 
```

##BA and # stems by DMR
This time, calculate the BA and number of stems on a per hectare basis in 
each DMR class at each site. 
```{r}
mat.dmr <- mat.hwba %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Filter out dmr class '-' because these are non-Hw or Ba trees
mat.dmr <- mat.dmr %>% filter(dmr_f2 != "-")

#Widen dataframe so each DMR class is a column
mat.dmr <- pivot_wider(mat.dmr, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha, nstem_ha))

#Join these back to results table
mat_infection <- left_join(mat_infection, mat.dmr, by = "site_id")
```

###Graph this breakdown
Break down Hw/Ba BA and # of stems (perha) by site, DMR and dbh  class. 
Then graph it. 
```{r}
mat.dmr_dbh <- mat.hwba %>% 
  group_by(site_id, dmr_f2, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Check levels in DMR factor
#Because there is no non-hosts, can remove first level ("-")
levels(mat.dmr_dbh$dmr_f2)

#Recode this factor
mat.dmr_dbh <- mat.dmr_dbh %>% 
  mutate(dmr_f2 = as.character(dmr_f2)) %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("DU", "0", "IBLC", "1-2",
  "3-4", "5-6", "DI")))

#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.dmr_dbh <- mat.dmr_dbh %>% 
  filter(ba_m2_ha > 0) 

#Plot
#By number of stems
p <- ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Modified DMR")

#Export this plot
# pdf(here("./figures/mat_inf_nstem_ha.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#By basal area
levels(mat.dmr_dbh$dmr_f2)
ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "none",
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 24),
        strip.text = element_text(size = 16)) + 
  labs(x = "DBH bin", y = expression("Basal area (m"^2*")"))
```

##Stand DMR and DMI of each site
  - Stand DMR = mean DMR of all live susceptible trees (an proxy of infection 
  severity at a site)
  - DMI = mean DMR of all live infected trees (a proxy of infection severity
  where it occurs)
```{r}
mat.s_dmr_dmi <- mat.hwba %>% 
  filter(status %in% c("LS", "LL", "LF")) %>% 
  group_by(site_id) %>% 
  summarise(mat.s_dmr = mean(dmr),
            mat.s_dmi = mean(dmr[hdm_pa == "Y"]))

#Join these back to results table
mat_infection <- left_join(mat_infection, mat.s_dmr_dmi, by = "site_id")
```

##Export
```{r}
#Export table with infection metrics for future writing/analyses
# write_csv(mat_infection, here("./tables/mat_infection.csv"))
```

#SECTION 4 - Compare infection levels in regen trees
Approach this similarly to mature component. We will use number of stems and
basal area for metrics. There is the added component of a spatial dimension - 
we want to know how infection changes based on how far a tree is away from the 
edge. The regen transects were variable in length and we will need to account 
for that; we'll do that by comparing 0-15m (which is within the zone of 
influence of the mature component and only contains measured trees) and 0-50 
(which  extends past the zone of influece and will contain simulated trees for 
all but one site, to varying extents). 

Start by removing residual trees from the regen datasets. 
```{r}
#Read in residual tree dataset
resid <- read_csv(here("./data/raw/residual reference tree data.csv"))

#How many residual trees are there? 
resid <- resid %>% filter(tree_type == "residual")
nrow(resid) #10

#How many are on a regen transect?
resid %>% filter(!is.na(regen_tree_id)) %>% nrow() #5

#Lets remove these from the trees datasets
resid_rm <- resid %>% filter(!is.na(regen_tree_id)) %>% 
  pull(regen_tree_id)

#Add column to trees datasets that identifies which trees are residuals
regen_15 <- regen_15 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))
regen_50 <- regen_50 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))

#How many are <15m from edge?
regen_15 %>% select(resid) %>% table()

#How many are >50m from the edge?
regen_50 %>% select(resid) %>% table()

#Filter out the residual trees
regen_15 <- regen_15 %>% filter(resid == "N")
regen_50 <- regen_50 %>% filter(resid == "N")
```

Then create an object to append results to and subset the two working 
dataframes to just hw trees. 
```{r}
#Create dataframe to append results to
reg_infection <- site %>% 
  select(site_id)

#Subset two trees objects
reg.hw_15 <- regen_15 %>% 
  filter(spp == "Hw")
reg.hw_50 <- regen_50 %>% 
  filter(spp == "Hw")
```

Estimate total Hw basal area and number of stems per hectare. 
```{r}
reg.hw_ba_nstem_15 <- reg.hw_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_15 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_15 = sum(phf_site))
reg.hw_ba_nstem_50 <- reg.hw_50 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_50 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_50 = sum(phf_site))

#Join estimates to working results dataframe
reg_infection <- left_join(reg_infection, reg.hw_ba_nstem_15, by="site_id")
reg_infection <- left_join(reg_infection, reg.hw_ba_nstem_50, by="site_id")
```

##How many trees were simulated?
Calculate the proportion of all trees and Hw simulated at each site. 
```{r}
#Get counts of all trees, all simulated trees, all Hw and simulated Hw
reg.sim <- regen_50 %>% 
  group_by(site_id) %>% 
  summarise(nstem_all = n(),
            nstem_sim = sum(sim_tree == "Y"),
            nstem_hw = sum(spp == "Hw"),
            nstem_hw_sim = sum (spp=="Hw" & sim_tree == "Y"))

#Calculate proportions
reg.sim <- reg.sim %>% 
  mutate(reg.p_sim = nstem_sim/nstem_all,
         reg.p_hw_sim = nstem_hw_sim/nstem_hw)

#Join these back to the working results dataframe
x <- reg.sim %>% select(site_id, starts_with("reg.p"))
reg_infection <- left_join(reg_infection, x, by = "site_id")
```

##Infection perimeter
We are defining infection perimeter as the distance from the edge below which 
90% of the infected Hw occur. Its better than using the most distant tree 
because it uses more than just one datapoint; the exception is when there is 
just one or two infected trees at a site. In those cases, it will be 
disproportinately determined by those trees. Calculate it here. 

General trends: 
  - At the transect level, it ranges from 0-48.9m
  - At the site level, the means range from 2.4 to 33.2m
```{r}
#plot_id == transect_id
#Used if_else statement because if there are no infected Hw, then infection
#perimeter is 0
reg.infper <- regen %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id, plot_id) %>% 
  summarise(reg.infper = if_else(sum(hdm_pa == "Y")>0, 
                                 quantile(dist_y_h[hdm_pa == "Y"], probs = 0.9),
                                 0)) 
range(reg.infper$reg.infper) #0's kept

#Summarize at the site level with mean and sd
reg.infper_s <- reg.infper %>% group_by(site_id) %>% 
  summarise(reg.infper_mean = mean(reg.infper), 
            reg.infper_sd = sd(reg.infper)) 
summary(reg.infper_s)

#Join these back to the results dataframe
reg_infection <- left_join(reg_infection, reg.infper_s, by="site_id")
```

##BA and nstems infected
Calculate the basal area and # of stems infected (per ha) at each site and with
those the percent infection by each metric. General trends:
  - Proportion infected (0-15m): mean = 0.49, range =0.01 - 0.80
  - Proportion infected (0-50): mean = 0.24, range = 0 - 0.56
  - Four outliers are obvious in this data: mk_3 (youngest site by far), 
  ph_1 (no clear explanation), ph_2 and ph_3 (both sites where Hw is not a 
  dominant species)
  
```{r}
reg.ba_nstem_inf_15 <- reg.hw_15 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_15 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_15 = sum(phf_site))

reg.ba_nstem_inf_50 <- reg.hw_50 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_50 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_50 = sum(phf_site))

#Join these stats back to results dataframe
reg_infection <- left_join(reg_infection, reg.ba_nstem_inf_15, by="site_id")
reg_infection <- left_join(reg_infection, reg.ba_nstem_inf_50, by="site_id")

#Calculate the proportion of Hw infected
reg_infection <- reg_infection %>% 
  mutate(reg.p_ba_m2_inf_15 = reg.ba_m2_ha_hw_inf_15/reg.ba_m2_ha_hw_15,
         reg.p_nstem_inf_15 = reg.nstem_ha_hw_inf_15/reg.nstem_ha_hw_15,
         reg.p_ba_m2_inf_50 = reg.ba_m2_ha_hw_inf_50/reg.ba_m2_ha_hw_50,
         reg.p_nstem_inf_50 = reg.nstem_ha_hw_inf_50/reg.nstem_ha_hw_50)

#Take a look
#For 0-15m
reg_infection %>% select(site_id, reg.ba_m2_ha_hw_15, reg.nstem_ha_hw_15,
                         reg.p_ba_m2_inf_15, reg.p_nstem_inf_15) %>% 
  arrange(reg.p_nstem_inf_15)
summary(reg_infection$reg.p_nstem_inf_15)

#For 0-50m
reg_infection %>% select(site_id, reg.ba_m2_ha_hw_50, reg.nstem_ha_hw_50,
                         reg.p_ba_m2_inf_50, reg.p_nstem_inf_50) %>% 
  arrange(reg.p_nstem_inf_50)
summary(reg_infection$reg.p_nstem_inf_50)
```
  
##Stand DMR and DMI
Calculate the stand DMR and DMI for 0-15m and 0-50m. Again, for reference: 
  - Stand DMR = mean DMR of all live susceptible trees (an proxy of infection 
  severity at a site)
  - DMI = mean DMR of all live infected trees (a proxy of infection severity
  where it occurs)
  - For the regen component, I am exlcuing Ba and just including Hw in my 
  definition of susceptible trees because its our target species. Including Ba 
  in the mature component is fair because it contributes to the infection 
  pressure. But in the regen component, want to retain a focus on Hw. 
```{r}
reg.s_dmr_dmi_15 <- reg.hw_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.s_dmr_15 = mean(dmr[status %in% c("LS", "LL", "LF")]),
            reg.s_dmi_15 = mean(dmr[status %in% c("LS", "LL", "LF") & 
                                   hdm_pa == "Y"]))

reg.s_dmr_dmi_50 <- reg.hw_50 %>% 
  group_by(site_id) %>% 
  summarise(reg.s_dmr_50 = mean(dmr[status %in% c("LS", "LL", "LF")]),
            reg.s_dmi_50 = mean(dmr[status %in% c("LS", "LL", "LF") & 
                                   hdm_pa == "Y"]))

##Join these stats back to results table
reg_infection <- left_join(reg_infection, reg.s_dmr_dmi_15, by="site_id")
reg_infection <- left_join(reg_infection, reg.s_dmr_dmi_50, by="site_id")

#Take a look
#0-15m
reg_infection %>% select(site_id, reg.s_dmr_15, reg.s_dmi_15) %>% 
  arrange(reg.s_dmr_15)
reg_infection %>% select(reg.s_dmr_15, reg.s_dmi_15) %>% summary()

#0-50m
reg_infection %>% select(site_id, reg.s_dmr_50, reg.s_dmi_50) %>% 
  arrange(reg.s_dmr_50)
reg_infection %>% select(reg.s_dmr_50, reg.s_dmi_50) %>% summary()
```

##Basal area and # of stems by DMR
Break down basal area and the number of stems (per ha) by DMR class.
```{r}
#Now find the basal area and number of stems (per ha) in each dmr class
reg.dmr_15 <- reg.hw_15 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_15 = sum(ba_m2*phf_site), 
            nstem_ha_15 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_15 <- reg.dmr_15 %>% 
  filter(dmr_f2 != "-")
reg.dmr_15 <- pivot_wider(reg.dmr_15, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_15, nstem_ha_15))

reg.dmr_50 <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_50 = sum(ba_m2*phf_site), 
            nstem_ha_50 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_50 <- reg.dmr_50 %>% 
  filter(dmr_f2 != "-")
reg.dmr_50 <- pivot_wider(reg.dmr_50, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_50, nstem_ha_50))

reg.dmr <- reg.dmr %>% filter(dmr_f2 != "-")
reg.dmr <- pivot_wider(reg.dmr, names_from = dmr_f2, 
                       values_from = c(ba_m2, nstem, ba_m2_15, nstem_15))

#Add these to results dataframe
reg_infection <- left_join(reg_infection, reg.dmr_15, by = "site_id")
reg_infection <- left_join(reg_infection, reg.dmr_50, by = "site_id")
```

###Graph this breakdown
Break down basal area and # of stems (per ha) by DMR class and distance from 
the edge. This is a pretty close to visual to what we are trying to model. 

Start by breaking distance from the edge into bin and then creating the 
dataframe with the breakdown. 
```{r}
#Break distance from the edge into 5m bins
reg.hw_50 <- reg.hw_50 %>% mutate(dist_y_h_bin = cut(dist_y_h, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))

#Do the breakdown
reg.dmr_disty <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2, dist_y_h_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>%
  complete(dist_y_h_bin, fill=list(ba_m2_ha = 0, nstem_ha = 0))
```

We want to indicate where measured trees stop and simulated trees begin at each
site. To do that, we need to find the last interval with measured data. We can 
add a label to the plot that indicates that's where measurements stopped. A few
sites had different length transects, when we extended a transect to cover some 
landscape feature (like a blowdown patch). We will just put a marker at the 
last interval that has measured data for ALL transects at a site. This means 
there will be some measured data passed that point at those sites with multiple
transect lengths, but it is also a true representation of where simulated data
begins. 
```{r}
#This is not an elegant solution
#tr_leng_s identifies the common transect length across ALL three transects
#at a site (i.e. the minimum transect length of the three transects)
#Create a simple dataframe with site_id, the distance bin that contains 
#tr_leng_s and a column containing "*" which will be our marker
x <- tran %>% group_by(site_id) %>% 
  summarise(tr_leng_s = min(tr_leng_s)) %>% 
  mutate(tr_leng_s = if_else(tr_leng_s > 50, 50, tr_leng_s))
x <- x %>% mutate(tr_leng_bin = cut(tr_leng_s, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))
x <- x %>% 
  mutate(tr_end = "*")

#Join this to the dataframe we will use for plotting
reg.dmr_disty <- left_join(reg.dmr_disty, select(x, site_id, tr_leng_bin, 
                                                 tr_end),
                           by = c("site_id" = "site_id",
                                  "dist_y_h_bin" = "tr_leng_bin"))

#Get the total bar height for a graph using number of stems and a grpah using
#BA. We will use this to define the y - coordinate for the marker
x2 <- reg.dmr_disty %>% 
  group_by(site_id, dist_y_h_bin) %>% 
  summarise(lab_pos_ba = sum(ba_m2_ha),
            lab_pos_nstem = sum(nstem_ha))

#Join this to the plotting dataframe
reg.dmr_disty <- left_join(reg.dmr_disty, x2,
                           by = c("site_id", "dist_y_h_bin"))
```

Then graph. 
```{r}
#By BA
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=ba_m2_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(aes(y = lab_pos_ba, label = tr_end, vjust = 0.1)) +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2, 
                    labels = c("Dead uninfected", "0",
                                 "Infected below \nlive crown",
                                 "1-2",
                                 "3-4",
                                 "5-6",
                                 "Dead uninfected")) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.01),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 20)) + 
  labs(x = "Distance from edge (m)", 
       y = expression("Basal area (m"^2*") per ha"), 
       fill = "Modified DMR") + 
  guides(fill = guide_legend(ncol = 1))

#Export this plot
# pdf(here("./figures/reg_dmr_disty_ba.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#By # of stems
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=nstem_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(aes(y = lab_pos_nstem, label = tr_end), 
            size = 10) +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16)) + 
  labs(x = "Distance from edge (m)", 
       y = "Trees per ha", 
       fill = "Modified DMR") + 
  guides(fill = guide_legend(ncol = 2))

#Export this plot
pdf(here("./figures/reg_dmr_disty_nstem.pdf"), width = 11, height = 8.5)
p
dev.off()
```

##Vertical infection distribution
We also want to summarize how infection is distributed in the tree. E.g. if its
a DMR 1, then we want to know whether the 1 is in the bottom, middle or upper 
crown. Lets do this, just for live Hw trees that have a DMR of >=1. The basic 
strategy is going to be to break down each tree level DMR (possible values for 
infected tree of 1-6) by the contributions of each crown third. 
```{r}
#Start by creating subsetting the dataframe to just DMR ratings (for the whole 
#tree and for the crown thirds).
reg.vpos <- reg.hw_50 %>% 
  filter(status %in% c("LS", "LL", "LF") & dmr >= 1) %>% 
  select(tree_id, site_id, crown_class, dmr, dmr_l, dmr_m, dmr_u)

#Divide each crown third rating by the total DMR to get the crown third 
#contribution
reg.vpos <- reg.vpos %>% 
  mutate(cont_l = dmr_l/dmr,
         cont_m = dmr_m/dmr,
         cont_u = dmr_u/dmr)

#Lengthen so that crown third contributions are a single column
reg.vpos <- reg.vpos %>% 
  select(-c(dmr_l, dmr_m, dmr_u)) %>% 
  pivot_longer(cols = starts_with("cont"),
               values_to = "cont",
               names_to = "ct",
               names_prefix = "cont_")

#Summarize this for each crown class. This creates groups for every unique
#crown class - dmr -crown third combination. Within each group, it takes each
#row and averages the contribution value for each crown third. 
reg.vpos <- reg.vpos %>% 
  group_by(crown_class, dmr, ct) %>% 
  summarise(cont = mean(cont),
            n_tree = n())
```

###Graph this distribution
```{r}
#We will use the n_tree column to label the plot with how many trees there are 
#for each crown class-dmr combination, but right now there are three values for
#every combination because the dataframe is also subset by crown third. We just
#need one
reg.vpos <- reg.vpos %>% 
  mutate(n_tree = if_else(ct == "l", n_tree, NA))

#Make crwon third a factor
reg.vpos <- reg.vpos %>% 
  mutate(ct = case_match(ct, 
                         "l" ~ "lower",
                         "m" ~ "middle",
                         "u" ~ "upper")) %>% 
  mutate(ct = factor(ct, levels = c("upper", "middle", "lower")))

p <- ggplot(reg.vpos, aes(x = dmr, y = cont, fill = ct)) + 
  geom_bar(stat = "identity", position = "stack") + 
  geom_text(aes(label = n_tree), y = 1, vjust = -0.5) +
  facet_wrap(~crown_class) +
  theme_classic() + 
  scale_y_continuous(limits = c(0, 1.1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  scale_fill_manual(values = colors_ct) + 
  theme(legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16)) + 
  labs(x = "DMR", 
       y = "Mean crown third contribution", 
       fill = "Crown third")

#Export this plot
# pdf(here("./figures/reg_vdist_inf.pdf"), width = 10, height = 8.5)
# p
# dev.off()
```

##Tables for writing/downstream analyses
We've built up a table of infection stats in the regen component in this 
script. We will pull from that and from the paired on in the mature component 
to compile a table for the thesis that summarizes infection levels. 
```{r}
#Vars: site_id and the distance to the infected tree farthest from the edge
#the latter is tr_leng_s in the transect dataset
t_the_inf <- site %>% select(site_id)
x <- tran %>% 
  group_by(site_id) %>% 
  summarise(out_dist_inf = min(tr_leng_s))
t_the_inf$out_inf_dist <- x$out_dist_inf

#Vars: infection perimeter and the percent of trees simulated
x <- reg_infection %>% 
  select(site_id, reg.infper_mean, reg.infper_sd, reg.p_sim) %>% 
  mutate(across(c(reg.infper_mean, reg.infper_sd), ~ round(., 1)))
x <- x %>% 
  mutate(reg.infper = paste0(reg.infper_mean, " (", reg.infper_sd,
                             ")"))
x <- x %>% 
  select(site_id, reg.infper, reg.p_sim) 
t_the_inf <- left_join(t_the_inf, x, by = "site_id")

#Vars: regen infection stats
x <- reg_infection %>% 
  select(site_id, reg.p_nstem_inf_15, reg.p_nstem_inf_50, reg.s_dmr_15,
         reg.s_dmr_50, reg.s_dmi_15, reg.s_dmi_50)
t_the_inf <- left_join(t_the_inf, x, by = "site_id")

#Vars: mature infection stats
x <- mat_infection %>% 
  select(site_id, mat.inf_ba_m2_ha, mat.p_nstem_inf, mat.s_dmr, mat.s_dmi)
t_the_inf <- left_join(t_the_inf, x, by = "site_id")

#Round the numbers to 2 or 1 figures
t_the_inf <- t_the_inf %>% 
  mutate(across(c(out_inf_dist, reg.s_dmr_15, reg.s_dmr_50, reg.s_dmi_15,
                  reg.s_dmi_50, mat.s_dmr, mat.s_dmi), ~ round(., 1)),
         across(c(reg.p_sim, reg.p_nstem_inf_15, reg.p_nstem_inf_50, 
                  mat.inf_ba_m2_ha, mat.p_nstem_inf), ~ round(., 2)))
```

Export this and the table with all of the regen infection summary stats. 
```{r}
#Table for thesis
# write_csv(t_the_inf, "./tables/thesis_inf_stats.csv")

#Table with all of the regen infection stats
# write_csv(reg_infection, "./tables/reg_infection.csv")
```

#Extra code
Presence/absence of infection in 5m intervals from the edge using basal area 
and dmr metrics.
```{r}
#Plot 3: basal area and number of stems infected as function of distance 
#from the edge
#Going to display these plots in 5m bins of distance. 
#Only want to show complete intervals with complete data (e.g. if a transect
#ends at 22.5m, we only want to show intervals up to 20m because the interval
#that appears as 20-25 only has half that data).
#Create new variable that takes the transect length and finds the nearest 
#lowest multiple of 5
reg.hw <- reg.hw %>% mutate(dist_cmplt_bin = floor(tr_leng_s/5)*5)

#Create a subdataframe that removes observations beyond this new variable
reg.hw.disty <- reg.hw %>% filter(dist_y_h<dist_cmplt_bin)

#Break up dist_y_h into intervals.
range(reg.hw.disty$dist_y_h)
reg.hw.disty <- reg.hw.disty %>% 
  mutate(dist_y_h_bin = cut(dist_y_h, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))
levels(reg.hw.disty$dist_y_h_bin)

#Summarize basal area and the # stems by site, presence/absence of hdm and 
#distance from the edge (in the 5m intervals created above)
#Only want to show complete intervals with complete data (e.g. if a transect
#ends at 22.5m, we only want to show intervals up to 20m because the interval
#that appears as 20-25 really only has half that data) 
g.reg_hdmpa_dy <- reg.hw.disty %>% 
  group_by(id_bec_age_f, hdm_pa, dist_y_h_bin) %>%
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>%
  complete(dist_y_h_bin, fill=list(ba_m2=0, nstem=0))

##Plot nstem and basal area vs. distance from the edge, coloured by 
#presence/absence of hdm infection
#Check/reorder hdm_pa variable
levels(g.reg_hdmpa_dy$hdm_pa)
ggplot(g.reg_hdmpa_dy, aes(x=dist_y_h_bin, y=nstem, fill=hdm_pa)) +
  theme_classic() +
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(id_bec_age_f)) + 
  scale_fill_manual(values = colors_hdm_pa) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "Distance from edge (m)", 
       y = expression("Number of stems"), 
       fill = "P/A of HDM") 

ggplot(g.reg_hdmpa_dy, aes(x=dist_y_h_bin, y=ba_m2, fill=hdm_pa)) + 
  geom_bar(position="stack", stat="identity") +
  theme_classic() +
  facet_wrap(vars(id_bec_age_f)) + 
  scale_fill_manual(values = colors_hdm_pa) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "Distance from edge (m)", 
       y = expression("Basal area (m"^2*")"), 
       fill = "P/A of HDM")
```


-Plots relating the propotion of infected stems, proportion of infected basal area and dmr distribution to distance from the edge
  -This is plot 3
  -The amount Hw is variable as a function of distance from the edge and the infection metrics seem to follow it (makes sense, bigger target area)
  - There are patterns of percent infection and dmr descreasing as a function of distance from the edge at some sites (e.g. cr_1, cr_2, mk_2, mi_1)
  - The severely infected trees (dmr 5-6) are all close to the edge (within 10m)

-Plots relating infection in regen to basal area of infection in mature component
  -This is Plot 4 (which combines p.minfba_rinfba and p.minfba_rpinfba)
  -There is a positive relationship here but only if you mentally remove the outliers (particularly mk_3 and ph_1)

-Plots relating infection perimeter to regen age
  -This is Plot 5
  -It sort of looks like there is something here but my sense is the range of age is too small and the replication is too low

Dual axis plot looking at coupling of infection perimeter and basal area for 
each site. 
```{r}
##Plot 1: dual axis plot looking at infection perimeter and basal area infected
##Need to set a scale factor for second axis. Basal area about 7 times smaller 
#than infper values. So factor = 7

#Create dataframe for plotting with infection perimeter and basal area by 
#transect
g.reg_infper_ba <- reg.hw %>% group_by(site_id, plot_id) %>% 
  summarise(reg.infper = if_else(sum(hdm_pa == "Y")>0, 
                                 quantile(dist_y_h, probs = 0.9),
                                 0),
            reg.inf_ba_m2 = sum(ba_m2[hdm_pa == "Y"]))
g.reg_infper_ba <- g.reg_infper_ba %>% mutate(plot_id = as.character(plot_id))
scale <- 24
ggplot(g.reg_infper_ba, aes(x=site_id, y=reg.infper, color=plot_id)) +
  geom_point(aes(shape = "infection perimeter (m2)")) +
  geom_point(aes(y=reg.inf_ba_m2*scale, shape = "basal area infected (m2)")) +
  scale_y_continuous(sec.axis = sec_axis(~./scale, name="basal area infected (m2)"))

```

Basic plots of DMR distribution using number of stems and BA
```{r}
#Plot set 2: basic distribution of dmr by site
#Do this for within 15m so its comparable across sites
g.reg_dmr <- regen_15 %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem =n()) %>%
  complete(dmr_f2, fill=list(ba_m2=0, nstem=0))
g.reg_dmr <- g.reg_dmr %>% filter(dmr_f2 != "-")

#By basal area
ggplot(g.reg_dmr, aes(x=dmr_f2, y=ba_m2, fill = dmr_f2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + scale_fill_manual(values = colors_dmr_f2)

#By number of stems
ggplot(g.reg_dmr, aes(x=dmr_f2, y=nstem, fill = dmr_f2)) + geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + scale_fill_manual(values = colors_dmr_f2)
```

A couple of plots at the site level that try to relate infection in the regen
to infection in the mature component. Generally, there isn't enough datapoints
to say anything meaningful here. 
  - First plot. Basal area infected in regen vs. basal area infected in mature
  component. 
  - Second plot. Infection perimeter vs. site age. 
```{r}
##############
#(27 Aug 2024). Commented out, not a very informative set of plots
# #Plot set 4: basal area infected in mature component to basal area infected 
#in the regen
# ggplot(reg_infection, aes(x=mat.inf_ba_m2, y=reg.inf_ba_m2, 
# color=id_bec_age_f)) +
#   geom_point()
# p.minfba_rpinfba <- ggplot(site, aes(x=mat.inf_ba_m2, y=reg.p_hw15_ba_inf, 
# color=id_bec_age_f)) +
#   geom_point()

##############
#(27 Aug 2024). Commented out, not a very informative set of plots
# #Plot set 5: infection perimeter as a function of site age
# ggplot(site, aes(x=age, y=reg.infper_m, color=id_bec_age_f)) +
#   geom_point()
```