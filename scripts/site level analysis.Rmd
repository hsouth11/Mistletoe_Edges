---
title: "Site Level Analyses"
author: "Hanno Southam"
date: "`r Sys.Date()`"
output: html_document
---
UPDATED: 31 Dec 2024
##############
READ ME
This script compares the 11 HDM study sites to eachother. 

Section 1 compares the different site climates, using data from Climate BC 
(https://climatebc.ca/mapVersion) and Barrett et al. (2012) as a framework for 
selecting and interpreting variables. 

Section 2 compares the size and composition of trees in the regen and mature 
components between sites. 

Section 3 compares HDM infection in the mature component between sites to get a 
high-level understanding if the infection sources are similar between sites. 

Section 4 compares HDM infection in the regen component between sites. 

Summary tables and figures are created in each section for writing and 
downstream analyses. The primary starting object for the script is the output
of the 'seed load.Rmd' script (trees_sl.csv). 

References
Barrett, T. M., Latta, G., Hennon, P. E., Eskelson, B. N. I., & Temesgen, H. (2012). Host–parasite distributions under changing climate: Tsuga heterophylla and Arceuthobium tsugense in Alaska. Canadian Journal of Forest Research, 42(4), 642–656. https://doi.org/10.1139/x2012-016
##############

#Load packages
```{r}
library(tidyverse)
library(here)
library(RColorBrewer)
library(ggrepel)
library(patchwork)
```

#Prep
##Load and format data
Read in and format the various datasets from the HDM sites
```{r}
rm(list=ls(all=TRUE))

##Dataset 1: site data. 
#This contains variables at the site level. The key pieces for analysis are: 
#year harvested and CWH subzone
site <- read_csv(here("data/cleaned/site data.csv"))
str(site)
summary(site)

#Order by site_id, used to seeing it in this order
site <- arrange(site, site_id)

#Create some variables to use in summary tables and figures
#Convert date_surveyed to date format
site <- site %>% rename(date_sur_char = date_surveyed) %>% 
  mutate(date_sur = dmy(date_sur_char)) %>% 
  relocate(date_sur, .after = date_sur_char)

#Extract year
site <- site %>% mutate(yr_sur = year(date_sur))
#Recalculate age column
site <- site %>% mutate(age = yr_sur - yr_har)
site$age #luckily, got pretty good spread

#Create a single variable from all the pieces of a BEC zone
site <- site %>% 
  unite(col = bec, sep = "", c("bec_z", "bec_sz", "bec_var"), remove = FALSE)

#Create a variable that combines site_id, bec, and regen age 
site <- site %>% unite(col = id_bec_age_f, sep = ", ", 
                       c("site_id", "bec", "age"), 
                       remove = FALSE) %>% 
  mutate(id_bec_age_f = factor(id_bec_age_f)) %>% 
  relocate(id_bec_age_f, .after = site_id)

#Make cluster, bec and id_bec_age_f factors
site <- site %>% mutate(across(c(cluster, bec, id_bec_age_f), ~as.factor(.)))
str(site)


#Dataset 2: transect data
#This describes the transects extending from the edge line into the regen
#component. There are three transects per site. Within a site, all transects
#are intended to be the same length; there were a couple exceptions (due to
#incorrect layout and one transect being extended to traverse a blowdown 
#patch). The length measured across all variables within a site is recorded 
#in the tr_leng_s variable. 
tran <- read_csv(here("./data/cleaned/transect data_c.csv"))
head(tran)
str(tran)


##Dataset 3: tree data
#This contains data for each measured tree (mature and regen trees)
#Using trees_sl object, which is the last trees object in the workflow
#Treats assessed_by var as a logical for some reason and throws up an error. 
#Not a problem and not going to use this var
trees <- read_csv("data/workflow/trees_sl.csv")
str(trees)
summary(trees)

#Convert factor vars to factors: 
trees <- trees %>% mutate(across(
  c(site_id, spp, status, hdm_pa, b_lc, 
    broom_pa, broom_pos, stem_pa, crown_class, crown_cond, outside_10, assessed_by, tree_type, dmr_f),
  ~as.factor(.)))

#Convert plot_id and dmrs to integers
trees <- trees %>% mutate(across(
  c(plot_id, dmr_l, dmr_m, dmr_u, dmr), ~as.integer(.)))

str(trees)

#Create new factor dmr variable that has fewer levels and ascends logically from healthy to most infected
levels(trees$dmr_f)
trees <- trees %>% 
  mutate(dmr_f2 = case_when((dmr_f =="1" | dmr_f=="2") ~ "1-2", 
                            (dmr_f =="3" | dmr_f=="4") ~ "3-4", 
                            (dmr_f =="5" | dmr_f=="6") ~ "5-6", 
                            .default = dmr_f))
trees <- trees %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("-", "DU", "0","IBLC", 
                                            "1-2", "3-4", "5-6", "DI")))
summary(trees$dmr_f2)

#Create new spp variable that sets all spp that aren't major species to "other"
maj_spp <- c("Hw", "Cw", "Fd", "Ba")
trees <- trees %>% 
  mutate(spp2 = if_else(spp %in% maj_spp, spp, "other")) %>% 
  mutate(spp2 = factor(spp2, levels = c("Hw", "Ba", "Cw", "Fd", "other")))

#Join some site level variables to tree data: 
trees <- left_join(trees, select(site, cluster, bec, 
                                 id_bec_age_f, age, site_id), by="site_id")

#Join identical transect length measured at each site to tree data
trees <- left_join(trees, select(tran, transect_id, tr_leng_s),
                   by = join_by("plot_id" == "transect_id"))
```

##Subset data to objects for different comparisons
There are a couple things we need to consider to ensure we are making fair 
comparisons throughout this script: 
(1) At a few sites we mapped mature trees up to 15m from the edge, when the 
standard was 10m.
(2) Regen transects are variable lengths (but constant within a site, with two
exceptions).  
(3) At two sites (mi_1) and (mk_3) the transect length within a site varied.

We want to make sure that whenever we are comparing two sites, we are comparing
trees from equivalent areas. 

Deal with the first of these right off the bat by removing mature trees >10m 
from the edge. 
```{r}
trees <- trees %>% filter(outside_10 =="N" | is.na(outside_10))
```

Calculate basal area (m^2) from dbhg. We will use this throughout the rest of 
the script
https://en.wikipedia.org/wiki/Basal_area
```{r}
trees <- trees %>% mutate(ba_m2 = pi*((dbh/100)/2)^2)
```

Break apart the dataset into different components. At the highest level, 
separate mature and regen components. Then within regen components, separate
out a dataset of trees <=15m from the edge and one of trees <=50m from the edge.

The minimum transect length was 15m, so all sites have data for 0-15m; this 
subset will be used to compare size an composition across sites and also for
HDM infection summaries within the zone of influence of the mature component. 
The dataset from 0-50m will include simulated trees to a different extent for
different sites; it will be used to provide HDM infection summaries over a 
larger range. 

A binned version of dbh is also created here for plotting to avoid creating it
multiple times when the objects are split apart. 
```{r}
#Subdivide data into mature and regen components
mature <- trees %>% filter(tree_type=="mature") 
regen <- trees %>% filter(tree_type == "regen") 

#Create bins of diameter classes from dbh
##Default is for intervals to be half-open. They include the upper bound but not the lower bound. e.g. (10,20] includes 20 but (20, 30] does not
## https://stackoverflow.com/questions/41304960/how-to-create-breaks-using-the-cut-function-without-numbers-overlapping
#Create a smaller bin for regen trees and a larger one for mature trees 
range(mature$dbh)
mature <- mature %>% 
  mutate(dbh_bin2 = cut(dbh, breaks = c(9, 15, 25, 35, 45, 55, 65, 75, 85,
                                       95, 105, 115, 125, 135, 145, 155,
                                       165, 175, 185, 195, 205, 300),
                       include.lowest = TRUE))

range(regen$dbh)
regen <- regen %>% 
  mutate(dbh_bin = cut(dbh, breaks = c(4, 10, 15, 20, 25, 30, 35, 40, 45,
                                       50, 55, 60, 65, 70, 75, 80,
                                       85, 90, 95, 100, 105, 110, 115, 120,
                                       125, 130, 135, 140, 145, 150, 155, 
                                       160, 165, 170, 175, 180, 185, 190, 
                                       195, 200, 300),
                       include.lowest = TRUE))

#Split regen object into datasets of <=15m and <=50m from edge
regen_15 <- regen %>% filter(dist_y_h <= 15)
regen_50 <- regen %>% filter(dist_y_h <= 50)
```

Create a conversion factor to represent trees on a per hectare basis. The 
comparisons in this script are at the site level, so this factor should 
represent each tree's contribution to the total area surveyed at a site; for 
mature trees, this is simple because there were no subunits but for regen trees
we need to pool the three transects. 
- Mature component footprint = 55x10m =550m2=0.055ha
- Regen transect footprint = # transects* transect length (15 or 50m) x 
5m = xx m2 = xx ha
```{r}
mature <- mature %>% mutate(phf_site = 1/(55*10/10000))
regen_15 <- regen_15 %>% mutate(phf_site = 1/(3*15*5/10000))
regen_50 <- regen_50 %>% mutate(phf_site = 1/(3*50*5/10000))
```

Often in this script, data gets filtered to just live tree classes. Save the 
status codes for live trees so we can call it. 
```{r}
live_stat <- c("LS", "LL", "LF")
```

##Plotting colours
Define some consistent colours to plot with
```{r}
display.brewer.all(colorblindFriendly = TRUE)
?brewer.pal()

#Different site clusters
colors_clust <- c("dodgerblue", "dodgerblue4", "cadetblue2", "cadetblue4")

#spp colours Ba, Cw, Fd, Hw, other
#Make Hw blue so it matches below
levels(trees$spp2)
#Get names of colours
brewer.pal(5, "Paired")
#Define the palette so Hw is blue
colors_spp <- c("#A6CEE3", "#1F78B4", "burlywood", "burlywood4", "#FB9A99")

#hdm_pa colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$hdm_pa)
#Reorder factor so that healthy trees are plotted on the bottom
trees$hdm_pa <- fct_relevel(trees$hdm_pa, "Y", "U", "N", "-")
colors_hdm_pa <- c("goldenrod1", "grey", "#A6CEE3")

#dmr_f2 colours. Didn't include a colour for non-Hw trees because not creating any plots with them and this variable here. 
levels(trees$dmr_f2)
colors_dmr_f2 = c("#1F78B4", "#A6CEE3", brewer.pal(4, "Oranges"), "hotpink")

#Crown third colours
colors_ct <- c("khaki1", "khaki3", "khaki4")
```

#SECTION 1: Site climate comparisons
Goal of this section is to descriptively describe differences in climate and 
physical (slope, aspect,elevation) between sites. The cliamte variables are 
ones with a conceptual link to HDM biology -- see Barrett et al. (2012). 
```{r}
####Read in climate data
#Data downloaded from ClimateBC (https://climatebc.ca/mapVersion, 24 Jun 2024). ClimateBCv7.50. Period: Normal_1991_2020
#Exception: cr_3 site, surveyed 17 Jul 2024, downloaded data 25 Aug 2024
climate <- read_csv('./data/raw/hdm_climdata.csv') #raw data from climateBC

####Check coordinates were inputted correctly, then join site_ids 
#Sites are identified by coordinates in the climate dataset. Check they are right before joining site_ids
site <- site %>% mutate(dd_X_r = round(dd_X, digits = 4), #round number of decimals to match climateBC rounding
                        dd_Y_r = round(dd_Y, digits = 5))
x <- site$dd_X_r - climate$long
y <- site$dd_Y_r - climate$Lat
print(x); print(y)
#Good, almost al 0s, just one that is different by 1 x 10e-4 (a rounding error)

#Join site_id, bec and cluster by latitude values
climate <- left_join(climate, select(site, site_id, cluster, bec, dd_Y_r), by = c("Lat" = "dd_Y_r"))

#move site_id to the front
climate <- climate %>% select(site_id, cluster, bec, everything())

#Define climate variables that were in Bianca's paper
#Descriptions of these variables and whether they are exact matches or approximiations of variables used in paper are in: /Users/hannosoutham/Library/CloudStorage/OneDrive-UBC(1)/Msc/Thesis/ch1.docx

#1 Growing degree days
climate <- climate %>% rowwise() %>% mutate(DD5_gs = sum(c_across(DD5_sp:DD5_at)))
select(climate, DD5, DD5_gs)

#2 Growing season radians
climate <- climate %>% rowwise() %>% mutate(Rad_gs = mean(c_across(Rad_sp:Rad_at)))
select(climate, MAR, Rad_gs)

#3 Lowest average minimum monthly temperature (Tmin_wt)
# find lowest Tmin value across all months
climate <- climate %>% rowwise() %>% mutate(Tmin_all = min(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_wt, Tmin_all)

#4 Standard deviation of lowest average minimum monthly temperature  
# calculate the standard deviation in Tmin across all of the months
climate <- climate %>% rowwise() %>% mutate(Tmin_sd = sd(c_across(Tmin_01:Tmin_12)))
select(climate, Tmin_sd)

#5 Snow (PAS) 
select(climate, MAP, PAS)

#6 Rain
climate <- climate %>% mutate(PAR = MAP-PAS)
select(climate, MAP, PAR, PAS)

#7 Lowest average spring monthly temperature
# Find lowest Tmin value between May and June
climate <- climate %>% rowwise() %>% mutate(Tmin_mj = min(c_across(Tmin_05:Tmin_06)))
select(climate, Tmin_mj)

#8 Lowest average fall monthly temperature (Tmin_at)
# Find the lowest Tmin value between August and September
climate <- climate %>% rowwise() %>% mutate(Tmin_as = min(c_across(Tmin_08:Tmin_09)))
select(climate, Tmin_as)

#Filter table to just the variables we are interested in and some others that
#are good general descriptors (MAT, TD, MAP)
climate <- climate %>% 
  select(site_id, cluster, bec, MAT, TD, MAP, PAR, PAS, DD5_gs, Rad_gs, 
         Tmin_all, Tmin_sd, Tmin_mj, Tmin_as) 

####Graph this
#Define levels of bec zone in an order that corresponds to wettest to driest
levels(climate$bec)
climate <- climate %>% 
  mutate(bec = factor(bec, levels = c("CWHvm2", "CWHvm1", "CWHdm-", "CWHxm2")))

#Create a long dataframe so a variables can be plotted in one go
clim_g <- climate %>%
  pivot_longer(MAT:Tmin_as, names_to = "climvar", values_to = "climval")

#Create a new colum with variable names and units
unique(clim_g$climvar)
clim_g <- clim_g %>% 
  mutate(climvar2 = case_match(climvar,
                               "MAT" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "TD" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "MAP" ~ paste0(climvar, " (mm)"),
                               "PAR" ~ paste0(climvar, " (mm)"),
                               "PAS" ~ paste0(climvar, " (mm)"),
                               "DD5_gs" ~ paste0(climvar, " (", "\u00B0", "C)"),
                               "Rad_gs" ~ paste0(climvar, " (MJ m", 
                                                 "-2", " d", 
                                                 "-1", ")"),
                               "Tmin_all" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_sd" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_mj" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)"),
                               "Tmin_as" ~ paste0(climvar, " (", "\u00B0", 
                                                   "C)")
                               )) %>% 
  mutate(climvar2 = factor(climvar2, levels = c("MAT (°C)", "TD (°C)", 
                                                "Tmin_all (°C)", "Tmin_sd (°C)",
                                                "Tmin_as (°C)", "Tmin_mj (°C)",
                                                "Rad_gs (MJ m-2 d-1)",
                                                "DD5_gs (°C)",
                                                "MAP (mm)", "PAR (mm)", 
                                                "PAS (mm)")))
unique(clim_g$climvar2)

#Create a plot
p <- ggplot(clim_g, aes(x=bec, y=climval, label=site_id, color = cluster)) +
  geom_text_repel(size = 2) +
  geom_point() +
  facet_wrap(~climvar2, scales = "free_y") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1, vjust = 0.5),
        legend.position = "inside",
        legend.position.inside = c(0.88,0.05),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 14),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  labs(x = "BEC", 
       y = "Climate variable value",
       colour = "Site cluster") +
  scale_color_manual(values = colors_clust)
p

#Export this plot
# pdf(here("./figures/climate_vars.pdf"), width = 11, height = 8.5)
# p
# dev.off()
```

##Assemble output tables
Build clean tables combining physical and climate variables. We will 
create two: (1) a large one with site id, cluster, elevation, slope, aspect, 
BEC zone and all the climate variables that we can use in other downstream 
analyses and to create tables I didn't think of in the future and (2) a smaller 
one for thesis that includes site_id, cluster, elevation, slope, aspect and 
a few descriptive climate variables.

Start by out climate variables described above. Also include MAT (mean annual 
temperature), TD (temperature difference betweenmean coldest month temperature 
and mean warmest month temperature) and MAP (mean annual precipitation) because 
they are good descriptors
```{r}
climate2 <- climate %>% 
  select(site_id, cluster, bec, MAT, TD, MAP, PAR, PAS, DD5_gs, Rad_gs, 
         Tmin_all, Tmin_sd, Tmin_mj, Tmin_as) 
```

Then add physical variables. Slope is a bit tricky here. There are two sets of 
slopes, slopes for the transect and slopes for the fall line. For both of those
sets we measured slope at multiple places to capture changes in slope profile.
For the purpose of creating a descriptive table of site characteristics for 
writing, we will select the measurement that capture the general fall line 
slope of the regen component. Need to reference the notes in the csv to know
which ones to pick here. 
```{r}
#Add elevation
climate2$elevation <- site$elevation

#Subset transect data to slope variables
slope <- tran %>% select(site_id, transect_id, starts_with("fl"))

#Add declination
x <- site %>% select(site_id, Dec)
slope <- left_join(slope, x, by = "site_id")

#Two slopes were taken for fall line only at two sites (cr_1 and cr_2). Both
#cases were places where the mature component sloped into a creek. The first 
#measurement captured the bank down to the creek, the second captured the 
#profile in the regen. We want the second. 
slope <- slope %>% 
  mutate(reg_sl = if_else(!is.na(fl_sl2), fl_sl2, fl_sl1),
         reg_az = if_else(!is.na(fl_az2), fl_az2, fl_az1)
         )

#Then correct for declination for fall line azimuth measurements taken with the
#rangefinder. One case where suspected error (recorded as compass but should
#have been rangefinder); fix that.
slope <- slope %>% 
  mutate(fl_az_device = case_when(transect_id == 102 ~ "rangefinder",
                                  .default = fl_az_device))
slope <- slope %>% 
  mutate(reg_az_corr = case_match(fl_az_device,
                                  "compass" ~ reg_az,
                                  "rangefinder" ~ ((reg_az) + Dec)%%360))

#Summarize these by site (take mean)
slope <- slope %>% 
  group_by(site_id) %>% 
  summarise(reg_az = round(mean(reg_az), 1),
            reg_sl = round(mean(reg_sl), 1))

#Join these to the table
climate2 <- left_join(climate2, slope, by = "site_id")
```

Export the tables. 
```{r}
#Subset a table for thesis
climate3 <- climate2 %>% select(site_id, cluster,
                                bec, elevation, reg_az, reg_sl,
                                MAT, Tmin_all, MAP, PAR, PAS)

#Export
# write_csv(climate2, "./tables/site_climphys_big.csv")
# write_csv(climate3, "./tables/site_climphys_small.csv")
```

#SECTION 2: Size class distribution and species composition
Here we compare the composition and size class distribution of the trees 
between sites. We will use the 'regen_15' object for the regen component
because that is object contains only measured trees; it will be free from any
bias created by simulating trees. As a general principle, usually two versions
of each metric are created, one on a raw basis and one on a perhectare basis. 
```{r}
#Create a couple of dataframes to append results to
reg_cs <- site %>% select(site_id)
mat_cs <- site %>% select(site_id)
```

##Basal area, stem density
Start by basic site level metrics: basal area, number of stems. This is for all
measured trees (live and dead).
```{r}
#Regen
reg.ba_nstem <- regen_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2 = sum(ba_m2),
         reg.nstem = n(),
         reg.ba_m2_ha = sum(ba_m2*phf_site),
         reg.nstem_ha = sum(phf_site))

#Mature
mat.ba_nstem <- mature %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2 = sum(ba_m2),
         mat.nstem = n(),
         mat.ba_m2_ha = sum(ba_m2*phf_site, na.rm = TRUE),
         mat.nstem_ha = sum(phf_site, na.rm = TRUE))

#Join these to results table
reg_cs <- left_join(reg_cs, reg.ba_nstem, by="site_id")
mat_cs <- left_join(mat_cs, mat.ba_nstem, by="site_id")

#Print a summary table, see how they compare:
reg_cs %>% select(site_id, reg.ba_m2:reg.nstem_ha) %>% 
  arrange(reg.ba_m2_ha)
mat_cs %>% select(site_id, mat.ba_m2:mat.nstem_ha) %>% 
  arrange(mat.ba_m2_ha)
```

##DBH, codominant tree layer
Next, summarize the dbh of the codominant/dominant trees at each site. Do it 
across all species and then for hemlock. At a few trees, crown class is 
recorded for dead trees when it shouldn't be. Want this to be for live trees
so also filter for those. 
```{r}
#Regen
reg.dbh <- regen_15 %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C" & status %in% live_stat) %>% 
  summarise(reg.dbh_mean_cd_all = mean(dbh, na.rm = T),
            reg.dbh_sd_cd_all = sd(dbh, na.rm = T),
            reg.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            reg.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Mature
mat.dbh <- mature %>% 
  group_by(site_id) %>% 
  filter(crown_class_2 == "C" & status %in% live_stat) %>% 
  summarise(mat.dbh_mean_cd_all = mean(dbh, na.rm = T),
            mat.dbh_sd_cd_all = sd(dbh, na.rm = T),
            mat.dbh_mean_cd_hw = mean(dbh[spp == "Hw"], na.rm = T),
            mat.dbh_sd_cd_hw = sd(dbh, na.rm = T))

#Join these back to the results dataframes
reg_cs <- left_join(reg_cs, reg.dbh, by="site_id")
mat_cs <- left_join(mat_cs, mat.dbh, by="site_id")

#Take a look at them
reg_cs %>% select(site_id, contains("dbh")) %>% arrange(reg.dbh_mean_cd_all)
mat_cs %>% select(site_id, contains("dbh")) %>% arrange(mat.dbh_mean_cd_all)
```

##Percent makeup of Hw
Here, calculate how much of the basal area and stems at a site are made up of 
Hw. These are useful summary stats and tell us about host avaialbility across
the sites. 
```{r}
##Regen
reg.ba_nstem_hw <- regen_15 %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>%
  summarise(reg.ba_m2_hw = sum(ba_m2),
            reg.nstem_hw = n())
  
#Add to results dataframe
reg_cs <- left_join(reg_cs, reg.ba_nstem_hw, by="site_id")

#Calculate proportion of total basal area and stems made up of hw
reg_cs <- reg_cs %>% 
  mutate(reg.p_ba_hw = reg.ba_m2_hw/reg.ba_m2,
         reg.p_stem_hw = reg.nstem_hw/reg.nstem)

##Mature
mat.ba_nstem_hw <- mature %>% 
  filter(spp == "Hw") %>% 
  group_by(site_id) %>% 
  summarise(mat.ba_m2_hw = sum(ba_m2),
            mat.nstem_hw = n())

##Add to results dataframe
mat_cs <- left_join(mat_cs, mat.ba_nstem_hw, by="site_id")
mat_cs <- mat_cs %>% 
  mutate(mat.p_ba_hw = mat.ba_m2_hw/mat.ba_m2,
         mat.p_stem_hw = mat.nstem_hw/mat.nstem)

##Print a summary table. 
#Hw makes up between 11 and 95% in regen and between 10% and 97% in mature 
#component. Two Ucluelet sites (ph_2 and ph_3) are outliers, with low 
#Hw percentages. Spread of Hw percentage more continuous in mature; 
#in regen, most sites have >70% Hw and only ph_2 and ph_3 are <50%. 
reg_cs %>% 
  select(site_id, reg.ba_m2, reg.ba_m2_hw, reg.p_ba_hw) %>% 
  arrange(reg.ba_m2)
mat_cs %>% select(site_id, mat.ba_m2, mat.ba_m2_hw, mat.p_ba_hw) %>% 
  arrange(mat.ba_m2)
```

##Basal area and stem density by species and diameter class
Break down basal area and stem density by species and diameter class. We can 
use this to create some graphs that summarize the tree composition at a site.
```{r}
#Do the breakdwon. A bit of a messy table, but graphed below
reg.struc <- regen_15 %>% group_by(site_id, spp, dbh_bin) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin, fill=list(ba_m2=0, nstem=0)) #add 0s in places there was no trees
mat.struc <- mature %>% group_by(site_id, spp, dbh_bin2) %>% 
  summarise(ba_m2 = sum(ba_m2), nstem = n()) %>% 
  complete(dbh_bin2, fill=list(ba_m2=0, nstem=0))#add 0s in places there was no trees

#Graph the species composition. See that Hw, Fd, Cw and Ba are major species
ggplot(reg.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
ggplot(mat.struc, aes(x=spp, y=ba_m2)) + 
  geom_bar(stat = "identity") + 
  facet_wrap(~site_id)
```

The major species at the sites are: Hw, Fd, Cw and Ba. We created a second
version of the species variable above that groups everything else as 'other'. 
Do the breakdown again and use this second species variable. Then use the 
breakdown to generate some plots, showing species composition across the sites. 
```{r}
#Summarize ba and nstems by species and diameter class again
#This time use spp2, which lists all non major spp as other
reg.struc <- regen_15 %>% 
  group_by(site_id, spp2, dbh_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin, fill=list(ba_m2_ha=0, nstem_ha=0)) #add 0s in places there was no trees

mat.struc <- mature %>% 
  group_by(site_id, spp2, dbh_bin2) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha=0, nstem_ha=0))#add 0s in places there was no trees

#Regen
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
reg.struc <- reg.struc %>% filter(ba_m2_ha>0) 

#PLOT. 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(reg.struc, aes(x=dbh_bin, y=nstem_ha, fill=spp2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")
p

#Export this plot
# pdf(here("./figures/reg_comp.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(reg.struc, aes(x=dbh_bin, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  

##Mature
#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.struc <- mat.struc %>% filter(ba_m2_ha>0) #Remove rows with 0 because R will plot all dbh intervals (up to 180cm)

#PLOT 
##Number of stems (per ha) vs. dbh bin, coloured by species
p <- ggplot(mat.struc, aes(x=dbh_bin2, y=nstem_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) +  
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 13),
        axis.title = element_text(size = 16),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Species")  
p

#Export this plot
# pdf(here("./figures/mat_comp.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#PLOT. 
##Basal area (per ha) vs. dbh bin, coloured by species
ggplot(mat.struc, aes(x=dbh_bin2, y=ba_m2_ha, fill=spp2)) + 
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  theme_classic() +
  scale_fill_manual(values = colors_spp) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA)) + 
  labs(x = "DBH bin", y = "Basal area per ha", fill = "Species")  
```

##Summary table for thesis
We need to assemble a summary table for 'the thesis' that generally describes
the forest at the sites. It should contain: 
- site_id, 
- years since harvest 
- mature forest age estimates 
- stem density (and proportion of Hw) 
- basal area (and propotion of Hw)
- mean and sd of dbh of all trees 
- mean and sd of dbh for Hw
- height estimate of C/D Hw
- mature-regen height difference
- site history

Start with stuff that is already in the site table. 
```{r}
#Start with a skeleton table
cs_sum <- site %>% select(site_id, age, site_history) %>% 
  rename(yr_since_har = age)
```

Mature forest age estimates ar in the vri dataframe. Load that. At some sites
multiple vri polygons overlap the mature component. In those instances, 
use the average age estimate. 
```{r}
vri <- read_csv(here("./data/cleaned/vri_c.csv"))

#Subset to polygons representing mature components
mat.age <- vri %>% filter(tree_type == "mature")
nrow(mat.age)

#Estimated age of Hw in the layer 1 trees is in the AGE_HW column. Get average.
mat.age <- mat.age %>% 
  group_by(site_id) %>% 
  summarise(mat.age_hw = mean(AGE_HW, na.rm = T))

#Join these to the summary table
cs_sum$mat.age_hw <- mat.age$mat.age_hw 
cs_sum <- cs_sum %>% 
  relocate(mat.age_hw, .after = "yr_since_har")
```

Height estimates of the codominant/dominant Hw at each site are in the crown
volume dataset. Load that and calcualte the height difference. 
```{r}
cv <- read_csv(here("./data/workflow/crown_vol.csv"))

#Filter to co dominant/dominant layer
unique(cv$crown_class_2)
ht_cd <- cv %>% 
  filter(crown_class_2 == "C")

#Select just the relevant columns
ht_cd <- ht_cd %>% 
  select(site_id, tree_type, height_cv_est)

#Widen so that mature and regen heights are in separate columns
ht_cd <- pivot_wider(ht_cd, names_from = tree_type, 
                       values_from = height_cv_est) %>% 
  rename(reg.ht_cd_hw = regen, 
         mat.ht_cd_hw = mature)

#Calculate height difference 
ht_cd <- ht_cd %>% 
  mutate(ht_diff_cd_hw = mat.ht_cd_hw - reg.ht_cd_hw)

#Join this to the summary dataframe
cs_sum <- left_join(cs_sum, ht_cd, by = "site_id")

#Round the columns to one decimal
cs_sum <- cs_sum %>% 
  mutate(across(c(reg.ht_cd_hw, mat.ht_cd_hw, ht_diff_cd_hw), ~ round(., 1)))
```

To complete the job add the composition and dbh stats we created in this 
section. 
```{r}
#Add stem density and proportion of stem that are Hw
cs_sum <- cs_sum %>% 
  mutate(reg.nstem_ha = reg_cs$reg.nstem_ha,
         mat.nstem_ha = mat_cs$mat.nstem_ha,
         reg.p_stem_hw = reg_cs$reg.p_stem_hw,
         mat.p_stem_hw = mat_cs$mat.p_stem_hw) %>% 
  mutate(across(c(reg.nstem_ha, mat.nstem_ha), ~round(., 0)),
         across(c(reg.p_stem_hw, mat.p_stem_hw), ~round(., 2)),
         )

#Do the same but with basal area
cs_sum <- cs_sum %>% 
  mutate(reg.ba_m2_ha = reg_cs$reg.ba_m2_ha,
         mat.ba_m2_ha = mat_cs$mat.ba_m2_ha,
         reg.p_ba_hw = reg_cs$reg.p_ba_hw,
         mat.p_ba_hw = mat_cs$mat.p_ba_hw) %>% 
  mutate(across(c(reg.ba_m2_ha, mat.ba_m2_ha), ~round(., 0)),
         across(c(reg.p_ba_hw, mat.p_ba_hw), ~round(., 2)),
         )

#Then add dbh stats
cs_sum <- cs_sum %>% 
  mutate(reg.dbh_mean_cd_all = reg_cs$reg.dbh_mean_cd_all,
         mat.dbh_mean_cd_all = mat_cs$mat.dbh_mean_cd_all,
         reg.dbh_sd_cd_all = reg_cs$reg.dbh_sd_cd_all,
         mat.dbh_sd_cd_all = mat_cs$mat.dbh_sd_cd_all,
         reg.dbh_mean_cd_hw = reg_cs$reg.dbh_mean_cd_hw,
         mat.dbh_mean_cd_hw = mat_cs$mat.dbh_mean_cd_hw,
         reg.dbh_sd_cd_hw = reg_cs$reg.dbh_sd_cd_hw,
         mat.dbh_sd_cd_hw = mat_cs$mat.dbh_sd_cd_hw) %>% 
  mutate(across(reg.dbh_mean_cd_all:mat.dbh_sd_cd_hw, ~round(., 1)))


#Put site history at the end
cs_sum <- cs_sum %>% 
  relocate(site_history, .after = last_col())
```

It is neater to represent standard deviation in brackets after and estimate. 
The dbh columns here would benefit from that. Create new columns in that form. 
```{r}
cs_sum <- cs_sum %>% 
  mutate(reg.dbh_all = paste0(reg.dbh_mean_cd_all,
                              " (", reg.dbh_sd_cd_all, 
                              ")"),
         mat.dbh_all = paste0(mat.dbh_mean_cd_all,
                              " (", mat.dbh_sd_cd_all, 
                              ")"),
         reg.dbh_hw = paste0(reg.dbh_mean_cd_hw,
                              " (", reg.dbh_sd_cd_hw, 
                              ")"),
         mat.dbh_hw = paste0(mat.dbh_mean_cd_hw,
                              " (", mat.dbh_sd_cd_hw, 
                              ")"))
```

##Export tables
Export the summary table and the two tables that contain the composition and 
size stats for writing and other analyses. 
```{r}
#Export
# write_csv(cs_sum, here("./tables/comp_size_sum.csv"))
# write_csv(reg_cs, "./tables/reg_comp_size.csv")
# write_csv(mat_cs, "./tables/mat_comp_size.csv")
```

#SECTION 3: Compare infection levels in mature trees
We will do this using number of stems and basal area on a per hectare basis 
as metrics. Using both is useful because basal area captures biases in 
infection towards bigger or smaller trees. Generally we are trying to assess 
whether the mature components are similar infection sources. 

Amabalis fir (Ba) is another HDM host that was a significant portion of the 
sites near Ucluelet. We will include it in the workflow here. 

Start by creating a dataframe to add results to and getting some basic metrics
of Hw and Ba. 
```{r}
#Create a dataframe to append results to
mat_infection <- mat_cs %>% 
  select(site_id,  mat.nstem_ha, mat.ba_m2_ha)

#Filter to just Hw and Ba trees because these are the only ones we are 
#considering "significant hosts"
mat.hwba <- mature %>% filter(spp %in% c("Hw", "Ba"))

#Calculate basal area and number of stems made up of these spp
mat.hwba_summary <- mat.hwba %>% 
  group_by(site_id) %>% 
  summarise(mat.hwba_nstem_ha = sum(phf_site), 
            mat.hwba_ba_m2_ha = sum (ba_m2*phf_site))

#Add summary stats back to site data
mat_infection <- left_join(mat_infection, mat.hwba_summary, by="site_id")
```

##BA and # stems by P/A of HDM
Start simple and calculate the basal area and number of infected trees at 
each site. 
```{r}
mat.inf <- mat.hwba %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(mat.inf_ba_m2_ha = sum(ba_m2*phf_site), 
            mat.inf_nstem_ha = sum(phf_site)) 

#Join variables back to working dataframe
mat_infection <- left_join(mat_infection, mat.inf, by="site_id") 

#Calculate the proportion total and Hw + Ba stems/BA infected
mat_infection <- mat_infection %>% 
  mutate(mat.p_ba_inf = mat.inf_ba_m2_ha/mat.ba_m2_ha,
         mat.p_nstem_inf = mat.inf_nstem_ha/mat.nstem_ha,
         mat.p_hwba_ba_inf = mat.inf_ba_m2_ha/mat.hwba_ba_m2_ha,
         mat.p_hwba_nstem_inf = mat.inf_nstem_ha/mat.hwba_nstem_ha) 
```

Take a look at the spread of infection across the sites by each metric. 
  - By basal area, range is 0.37 to 1.00  of Hw/Ba but most (9/11) sites >0.8
  - By number of stems, range is 0.31 to 1.00 of Hw/Ba but most sites 
  (8/11) >0.75
  - Mature components have different basal areas so its important to look at 
  the magnitude (not just proportion) infected trees
```{r}
#Summary table sorted by proportion of BA infected
mat_infection %>% select(site_id, mat.ba_m2_ha, mat.hwba_ba_m2_ha, 
                         mat.inf_ba_m2_ha, mat.p_ba_inf, mat.p_hwba_ba_inf) %>% 
  arrange(mat.p_hwba_ba_inf) 

#Summary table sorted by proportion of stems infected
mat_infection %>% select(site_id, mat.nstem_ha, mat.hwba_nstem_ha, 
                         mat.inf_nstem_ha, mat.p_hwba_nstem_inf) %>% 
  arrange(mat.p_hwba_nstem_inf) 
```

###Graph this breakdown
Break down Hw/Ba BA and # of stems by site, presence/absence of HDM and dbh 
class. This will provide a much more interpretable summary of how infection is 
distributed in the mature component. 
```{r}
mat.hdmpa_dbh <- mat.hwba %>% 
  group_by(site_id, hdm_pa, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Because there are no non-host trees, the hdm_pa will now only have 
#trees in three of the four levels
levels(mat.hdmpa_dbh$hdm_pa)
mat.hdmpa_dbh %>% group_by(hdm_pa) %>% summarise(n_tree = n())

#Recode the factor the get rid of the fourth level
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% 
  mutate(hdm_pa = as.character(hdm_pa)) %>% 
  mutate(hdm_pa = factor(hdm_pa, levels = c("N", "U", "Y")))
#Check the levels
levels(mat.hdmpa_dbh$hdm_pa)

#Remove rows with 0 because R will plot all dbh intervals (300cm)
mat.hdmpa_dbh <- mat.hdmpa_dbh %>% filter(ba_m2_ha > 0)

#Plot. # of stems
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=hdm_pa)) +  
  theme_classic() +
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N"))
  
ggplot(mat.hdmpa_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=hdm_pa)) + 
  theme_classic() +
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_hdm_pa, breaks = c("Y", "U", "N")) 
```

##BA and # stems by DMR
This time, calculate the BA and number of stems on a per hectare basis in 
each DMR class at each site. 
```{r}
mat.dmr <- mat.hwba %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Filter out dmr class '-' because these are non-Hw or Ba trees
mat.dmr <- mat.dmr %>% filter(dmr_f2 != "-")

#Widen dataframe so each DMR class is a column
mat.dmr <- pivot_wider(mat.dmr, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha, nstem_ha))

#Join these back to results table
mat_infection <- left_join(mat_infection, mat.dmr, by = "site_id")
```

###Graph this breakdown
Break down Hw/Ba BA and # of stems (perha) by site, DMR and dbh  class. 
Then graph it. 
```{r}
mat.dmr_dbh <- mat.hwba %>% 
  group_by(site_id, dmr_f2, dbh_bin2) %>%
  summarise(ba_m2_ha = sum(ba_m2*phf_site), nstem_ha = sum(phf_site)) %>% 
  complete(dbh_bin2, fill=list(ba_m2_ha = 0, nstem_ha = 0))

#Check levels in DMR factor
#Because there is no non-hosts, can remove first level ("-")
levels(mat.dmr_dbh$dmr_f2)

#Recode this factor
mat.dmr_dbh <- mat.dmr_dbh %>% 
  mutate(dmr_f2 = as.character(dmr_f2)) %>% 
  mutate(dmr_f2 = factor(dmr_f2, levels = c("DU", "0", "IBLC", "1-2",
  "3-4", "5-6", "DI")))

#Remove rows with 0 because R will plot all dbh intervals (up to 180cm)
mat.dmr_dbh <- mat.dmr_dbh %>% 
  filter(ba_m2_ha > 0) 

#Plot
#By number of stems
p <- ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=nstem_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) + 
  labs(x = "DBH bin (cm)", y = "Trees per ha", fill = "Modified DMR")

#Export this plot
# pdf(here("./figures/mat_inf_nstem_ha.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#By basal area
levels(mat.dmr_dbh$dmr_f2)
ggplot(mat.dmr_dbh, aes(x=dbh_bin2, y=ba_m2_ha, fill=dmr_f2)) + 
  theme_classic() +
  geom_bar(position = position_stack(reverse = TRUE), stat="identity") +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "none",
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 24),
        strip.text = element_text(size = 16)) + 
  labs(x = "DBH bin", y = expression("Basal area (m"^2*")"))
```

##Brooming and stem infections
Calculate the number of stems (per ha) with brooms and stem infections. 
Restrict this to live trees because that is what we did in the regenerating 
component. In the revised survey protocol, we would have broom/stem infection 
data for the recently dead tree status trees but we were inconsistent about 
that in our initial data collection. The live trees were consistently measured 
for these fields. 
```{r}
x <- mat.hwba %>% 
  filter(status %in% c("LS", "LL", "LF")) %>% 
  group_by(site_id) %>% 
  summarise(mat.l_hwba_nstem_ha = sum(phf_site), 
            mat.l_hwba_nstem_wb = sum(phf_site[broom_pa == "Y"]),
            mat.l_hwba_nstem_si = sum(phf_site[stem_pa == "Y"]))
  
#Join these back to results table
mat_infection <- left_join(mat_infection, x, by = "site_id")

#Calculate proportion of live trees with brooming and stem infections
mat_infection <- mat_infection %>% 
  mutate(mat.p_l_hwba_nstem_ha_wb = mat.l_hwba_nstem_wb/mat.l_hwba_nstem_ha,
         mat.p_l_hwba_nstem_ha_si = mat.l_hwba_nstem_si/mat.l_hwba_nstem_ha)

#Take a look
mat_infection %>% select(mat.p_l_hwba_nstem_ha_wb, 
                         mat.p_l_hwba_nstem_ha_si) %>% summary()
```

##Stand DMR and DMI of each site
  - Stand DMR = mean DMR of all live susceptible trees (an proxy of infection 
  severity at a site)
  - DMI = mean DMR of all live infected trees (a proxy of infection severity
  where it occurs)
```{r}
mat.s_dmr_dmi <- mat.hwba %>% 
  filter(status %in% c("LS", "LL", "LF")) %>% 
  group_by(site_id) %>% 
  summarise(mat.s_dmr = mean(dmr),
            mat.s_dmi = mean(dmr[hdm_pa == "Y"]))

#Join these back to results table
mat_infection <- left_join(mat_infection, mat.s_dmr_dmi, by = "site_id")
```

##Summary table for thesis
Compile a summary table for thesis that summarizes site level estimates of key
infection variables. 
  - Variables: 
    - basal area infected (live and dead Hw and Ba)
    - proportion live and dead Hw and Ba stems infected 
    - average DMR (live Hw and Ba)
    - DMI (live Hw and Ba)
    - Proportion of live Hw and Ba stems with brooms
    - Proportion of live Hw and Ba stems with stem infection
  - Structure:
    - Rows: variables
    - Columns: mean, median, range
```{r}
#Pull out variables from mat_infection table
mat_inf2 <- mat_infection %>% 
  select(mat.inf_ba_m2_ha, mat.p_nstem_inf, mat.s_dmr, mat.s_dmi, 
         mat.p_l_hwba_nstem_ha_wb, mat.p_l_hwba_nstem_ha_si)

#Summarise estimates across sites
mat_inf2 <- mat_inf2 %>% 
  summarise(across(everything(), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}")) %>%
  pivot_longer(
    cols = everything(),
    names_to = c("Variable", "Stat"),
    names_pattern = "(.+)_(.+)"
  ) %>%
  pivot_wider(
    names_from = Stat,
    values_from = value
  ) %>% 
  mutate(across(where(is.numeric), ~ round(., 2))) %>% 
  mutate(range = paste0("[", min, "-", max, "]")) %>% 
  select(-c(min, max))
```

##Export
```{r}
#Table with all infection summary metrics
# write_csv(mat_infection, here("./tables/mat_infection.csv"))

#Table for subset to report in thesis
# write_csv(mat_inf2, here("./tables/mat_infection_thesis.csv"))
```

#SECTION 4 - Compare infection levels in regen trees
This section focuses on Hw (because it is our target tree). Amabalis fir (Ba)
that we considered in the mature component is only important at one site and 
is much less affected by HDM. The ordinal modelling only considers Hw, so 
taking this approach here aligns with that. 

It is broken into two subsections. The first that looks at infections across 
live and dead trees, while the second looks just at live trees. 

Both subsections break summary stats down into intervals from the edge. 
  - 0-15m which is within the zone of influence of the mature component and 
  only contains measured trees
  - 0-50 which extends past the zone of influence and will contain simulated 
  trees for all but one site, to varying extents 

Start by removing residual trees from the regen datasets. 
```{r}
#Read in residual tree dataset
resid <- read_csv(here("./data/raw/residual reference tree data.csv"))

#How many residual trees are there? 
resid <- resid %>% filter(tree_type == "residual")
nrow(resid) #10

#How many are on a regen transect?
resid %>% filter(!is.na(regen_tree_id)) %>% nrow() #5

#Lets remove these from the trees datasets
resid_rm <- resid %>% filter(!is.na(regen_tree_id)) %>% 
  pull(regen_tree_id)

#Add column to trees datasets that identifies which trees are residuals
regen_15 <- regen_15 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))
regen_50 <- regen_50 %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N"))

#How many are <15m from edge?
regen_15 %>% select(resid) %>% table()

#How many are >50m from the edge?
regen_50 %>% select(resid) %>% table()

#Filter out the residual trees
regen_15 <- regen_15 %>% filter(resid == "N")
regen_50 <- regen_50 %>% filter(resid == "N")
```

##Infection in live and dead regen Hw
Create an object to append results to and subset the two working 
dataframes to just Hw trees. 
```{r}
#Create dataframe to append results to
reg_i_all <- site %>% 
  select(site_id)

#Subset two trees objects
reg.hw_15 <- regen_15 %>% 
  filter(spp == "Hw")
reg.hw_50 <- regen_50 %>% 
  filter(spp == "Hw")
```

Estimate total Hw basal area and number of stems per hectare. 
```{r}
reg.hw_ba_nstem_15 <- reg.hw_15 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_15 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_15 = sum(phf_site))
reg.hw_ba_nstem_50 <- reg.hw_50 %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_50 = sum(ba_m2*phf_site),
            reg.nstem_ha_hw_50 = sum(phf_site))

#Join estimates to working results dataframe
reg_i_all <- left_join(reg_i_all, reg.hw_ba_nstem_15, by="site_id")
reg_i_all <- left_join(reg_i_all, reg.hw_ba_nstem_50, by="site_id")
```

###How many trees were simulated?
Calculate the proportion of all trees and Hw simulated at each site. 
```{r}
#Get counts of all trees, all simulated trees, all Hw and simulated Hw
reg.sim <- regen_50 %>% 
  group_by(site_id) %>% 
  summarise(nstem_all = n(),
            nstem_sim = sum(sim_tree == "Y"),
            nstem_hw = sum(spp == "Hw"),
            nstem_hw_sim = sum (spp=="Hw" & sim_tree == "Y"))

#Calculate proportions
reg.sim <- reg.sim %>% 
  mutate(reg.p_sim = nstem_sim/nstem_all,
         reg.p_hw_sim = nstem_hw_sim/nstem_hw)

#Join these back to the working results dataframe
x <- reg.sim %>% select(site_id, starts_with("reg.p"))
reg_i_all <- left_join(reg_i_all, x, by = "site_id")
```

###BA and nstems infected
Calculate the basal area and # of stems infected (per ha) at each site and with
those the percent infection by each metric. General trends:
  - Proportion infected (0-15m): mean = 0.49, range =0.01 - 0.80
  - Proportion infected (0-50): mean = 0.24, range = 0 - 0.56
  - Four outliers are obvious in this data: mk_3 (youngest site by far), 
  ph_1 (no clear explanation), ph_2 and ph_3 (both sites where Hw is not a 
  dominant species)
```{r}
reg.ba_nstem_inf_15 <- reg.hw_15 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_15 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_15 = sum(phf_site))

reg.ba_nstem_inf_50 <- reg.hw_50 %>% 
  filter(hdm_pa =="Y") %>% 
  group_by(site_id) %>% 
  summarise(reg.ba_m2_ha_hw_inf_50 = sum(ba_m2*phf_site), 
            reg.nstem_ha_hw_inf_50 = sum(phf_site))

#Join these stats back to results dataframe
reg_i_all <- left_join(reg_i_all, reg.ba_nstem_inf_15, by="site_id")
reg_i_all <- left_join(reg_i_all, reg.ba_nstem_inf_50, by="site_id")

#Calculate the proportion of Hw infected
reg_i_all <- reg_i_all %>% 
  mutate(reg.p_ba_m2_inf_15 = reg.ba_m2_ha_hw_inf_15/reg.ba_m2_ha_hw_15,
         reg.p_nstem_inf_15 = reg.nstem_ha_hw_inf_15/reg.nstem_ha_hw_15,
         reg.p_ba_m2_inf_50 = reg.ba_m2_ha_hw_inf_50/reg.ba_m2_ha_hw_50,
         reg.p_nstem_inf_50 = reg.nstem_ha_hw_inf_50/reg.nstem_ha_hw_50)

#Take a look
#For 0-15m
reg_i_all %>% select(site_id, reg.ba_m2_ha_hw_15, reg.nstem_ha_hw_15,
                         reg.p_ba_m2_inf_15, reg.p_nstem_inf_15) %>% 
  arrange(reg.p_nstem_inf_15)
summary(reg_i_all$reg.p_nstem_inf_15)

#For 0-50m
reg_i_all %>% select(site_id, reg.ba_m2_ha_hw_50, reg.nstem_ha_hw_50,
                         reg.p_ba_m2_inf_50, reg.p_nstem_inf_50) %>% 
  arrange(reg.p_nstem_inf_50)
summary(reg_i_all$reg.p_nstem_inf_50)
```

###Basal area and # of stems by DMR
Break down basal area and the number of stems (per ha) by DMR class.
```{r}
#Now find the basal area and number of stems (per ha) in each dmr class
reg.dmr_15 <- reg.hw_15 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_15 = sum(ba_m2*phf_site), 
            nstem_ha_15 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_15 <- reg.dmr_15 %>% 
  filter(dmr_f2 != "-")
reg.dmr_15 <- pivot_wider(reg.dmr_15, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_15, nstem_ha_15))

reg.dmr_50 <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2) %>% 
  summarise(ba_m2_ha_50 = sum(ba_m2*phf_site), 
            nstem_ha_50 = sum(phf_site)) %>% 
  complete(dmr_f2, fill=list(ba_m2_ha = 0, nstem_ha = 0))
reg.dmr_50 <- reg.dmr_50 %>% 
  filter(dmr_f2 != "-")
reg.dmr_50 <- pivot_wider(reg.dmr_50, names_from = dmr_f2, 
                       values_from = c(ba_m2_ha_50, nstem_ha_50))

#Add these to results dataframe
reg_i_all <- left_join(reg_i_all, reg.dmr_15, by = "site_id")
reg_i_all <- left_join(reg_i_all, reg.dmr_50, by = "site_id")
```

####Graph this breakdown
Break down basal area and # of stems (per ha) by DMR class and distance from 
the edge. This is a pretty close to visual to what we are trying to model. 

Start by breaking distance from the edge into bin and then creating the 
dataframe with the breakdown.
```{r}
#Break distance from the edge into 5m bins
reg.hw_50 <- reg.hw_50 %>% mutate(dist_y_h_bin = cut(dist_y_h, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))

#Do the breakdown
reg.dmr_disty <- reg.hw_50 %>% 
  group_by(site_id, dmr_f2, dist_y_h_bin) %>% 
  summarise(ba_m2_ha = sum(ba_m2*phf_site), 
            nstem_ha = sum(phf_site)) %>%
  complete(dist_y_h_bin, fill=list(ba_m2_ha = 0, nstem_ha = 0))
```

We want to indicate where measured trees stop and simulated trees begin at each
site. To do that, we need to find the last interval with measured data. We can 
add a label to the plot that indicates that's where measurements stopped. A few
sites had different length transects, when we extended a transect to cover some 
landscape feature (like a blowdown patch). We will just put a marker at the 
last interval that has measured data for ALL transects at a site. This means 
there will be some measured data passed that point at those sites with multiple
transect lengths, but it is also a true representation of where simulated data
begins. 
```{r}
#This is not an elegant solution
#tr_leng_s identifies the common transect length across ALL three transects
#at a site (i.e. the minimum transect length of the three transects)
#Create a simple dataframe with site_id, the distance bin that contains 
#tr_leng_s and a column containing "*" which will be our marker
x <- tran %>% group_by(site_id) %>% 
  summarise(tr_leng_s = min(tr_leng_s)) %>% 
  mutate(tr_leng_s = if_else(tr_leng_s > 50, 50, tr_leng_s))
x <- x %>% mutate(tr_leng_bin = cut(tr_leng_s, 
                            breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                                       50), 
                            include.lowest = TRUE))
x <- x %>% 
  mutate(tr_end = "*")

#Join this to the dataframe we will use for plotting
reg.dmr_disty <- left_join(reg.dmr_disty, select(x, site_id, tr_leng_bin, 
                                                 tr_end),
                           by = c("site_id" = "site_id",
                                  "dist_y_h_bin" = "tr_leng_bin"))

#Get the total bar height for a graph using number of stems and a grpah using
#BA. We will use this to define the y - coordinate for the marker
x2 <- reg.dmr_disty %>% 
  group_by(site_id, dist_y_h_bin) %>% 
  summarise(lab_pos_ba = sum(ba_m2_ha),
            lab_pos_nstem = sum(nstem_ha))

#Join this to the plotting dataframe
reg.dmr_disty <- left_join(reg.dmr_disty, x2,
                           by = c("site_id", "dist_y_h_bin"))
```

Then graph. 
```{r}
#By BA
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=ba_m2_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(aes(y = lab_pos_ba, label = tr_end, vjust = 0.1)) +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2, 
                    labels = c("Dead uninfected", "0",
                                 "Infected below \nlive crown",
                                 "1-2",
                                 "3-4",
                                 "5-6",
                                 "Dead uninfected")) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.01),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 20)) + 
  labs(x = "Distance from edge (m)", 
       y = expression("Basal area (m"^2*") per ha"), 
       fill = "Modified DMR") + 
  guides(fill = guide_legend(ncol = 1))

#Export this plot
# pdf(here("./figures/reg_dmr_disty_ba.pdf"), width = 11, height = 8.5)
# p
# dev.off()

#By # of stems
p <- ggplot(reg.dmr_disty, aes(x=dist_y_h_bin, y=nstem_ha, fill=dmr_f2)) + 
  geom_bar(position=position_stack(reverse = TRUE), stat="identity") +
  geom_text(aes(y = lab_pos_nstem, label = tr_end), 
            size = 10) +
  theme_classic() +
  facet_wrap(vars(site_id)) + 
  scale_fill_manual(values = colors_dmr_f2) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = c(0.88, 0.1),
        legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16)) + 
  labs(x = "Distance from edge (m)", 
       y = "Trees per ha", 
       fill = "Modified DMR") + 
  guides(fill = guide_legend(ncol = 2))

#Export this plot
# pdf(here("./figures/reg_dmr_disty_nstem.pdf"), width = 11, height = 8.5)
# p
# dev.off()
```

##Infection in live regen Hw
When comparing to other papers, it became important to have infection metrics
for live trees and broken down by crown class. Most other papers report 
infection metrics for the something analagous to the live codominant layer so 
we need this for comparison. Infection metrics for these trees are created in
this subsection.

Filter to live Hw
```{r}
regen_15_l <- regen_15 %>% 
  filter(spp == "Hw" & status %in% live_stat & 
           sim_tree == "N")
regen_50_l <- regen_50 %>% 
  filter(spp == "Hw" & status %in% live_stat)
```

###Summary table for thesis
Variables:
  - Proportion of trees simulated
  - Proportion of Hw stems infected
  - Average DMR
  - DMI
  - Prop Hw stems with brooms
  - Prop Hw stems with stem infections
Structure: 
  - Rows: 
    - Interval (distnace from the edge; all, 0-15m or 0-50)
    - Crown class (all, C, I, S)
  - Columns: metrics
  
For reference: 
  - Average DMR = mean DMR of all live susceptible trees (an proxy of infection 
  severity at a site)
  - DMI = mean DMR of all live infected trees (a proxy of infection severity
  where it occurs)

Start with metrics that are summarized for each section x crown class 
combination: proportion of Hw stems infected, average Hw DMR and DMI and the 
proportion infected Hw with brooms and stem infections. Summarize them at the
site level first then again across sites, which is what will go in the 
summary table. 
```{r}
#Calcualte summary metrics at the site level
#For 0 - 15m
x <- regen_15_l %>% 
  group_by(site_id, crown_class_2) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            s_dmr = mean(dmr),
            s_dmi = if_else(length(dmr[hdm_pa == "Y"]) > 0,
                            mean(dmr[hdm_pa == "Y"]),
                            0),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"])) %>% 
  mutate(p_l_hw_inf = nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = nstem_ha_l_hw_si/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si))

#For 0-50m 
x1 <- regen_50_l %>% 
  group_by(site_id, crown_class_2) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            s_dmr = mean(dmr),
            s_dmi = if_else(length(dmr[hdm_pa == "Y"]) > 0,
                            mean(dmr[hdm_pa == "Y"]),
                            0),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"])) %>% 
  mutate(p_l_hw_inf = nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = nstem_ha_l_hw_si/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_inf, nstem_ha_l_hw_wb,
            nstem_ha_l_hw_si))

#Summarize each variable across sites
#For 0-15m
x <- x %>% 
  group_by(crown_class_2) %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}")) %>% 
  pivot_longer(
    cols = where(is.numeric), 
    names_to = c("variable", "metric"),
    names_pattern = "^(.*)_(mean|median|min|max)$",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = metric, 
              values_from = value) %>% 
  mutate(across(where(is.numeric), ~round(.x, 2))) %>% 
  mutate(range = paste0("[", min, "-", max, "]")) %>% 
  select(-c(min, max)) %>% 
  pivot_wider(names_from = variable,
              values_from = c(mean, median, range))

#For 0-50m
x1 <- x1 %>% 
  group_by(crown_class_2) %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}")) %>% 
  pivot_longer(
    cols = where(is.numeric), 
    names_to = c("variable", "metric"),
    names_pattern = "^(.*)_(mean|median|min|max)$",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = metric, 
              values_from = value) %>% 
  mutate(across(where(is.numeric), ~round(.x, 2))) %>% 
  mutate(range = paste0("[", min, "-", max, "]")) %>% 
  select(-c(min, max)) %>% 
  pivot_wider(names_from = variable,
              values_from = c(mean, median, range))

#Join the two datasets
x$sec <- "0_15"
x1$sec <- "0_50"
reg_i_live <- bind_rows(x, x1) %>% 
  relocate(sec, .before = everything())
```

That is super. Now repeat this for the same variables but ignoring crown 
class. Then append that to the working dataframe. 
```{r}
#Calculate each variable at the site level
#For 0-15m
x <- regen_15_l %>% 
  group_by(site_id) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_sim = sum(phf_site[sim_tree =="Y"]),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            s_dmr = mean(dmr),
            s_dmi = if_else(length(dmr[hdm_pa == "Y"]) > 0,
                            mean(dmr[hdm_pa == "Y"]),
                            0),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"])) %>% 
  mutate(p_sim = nstem_ha_l_hw_sim/nstem_ha_l_hw, 
         p_l_hw_inf = nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = nstem_ha_l_hw_si/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_sim, nstem_ha_l_hw_inf, 
            nstem_ha_l_hw_wb, nstem_ha_l_hw_si))

#For 0-50m
x1 <- regen_50_l %>% 
  group_by(site_id) %>% 
  summarise(nstem_ha_l_hw = sum(phf_site),
            nstem_ha_l_hw_sim = sum(phf_site[sim_tree == "Y"]),
            nstem_ha_l_hw_inf = sum(phf_site[hdm_pa=="Y"]),
            s_dmr = mean(dmr),
            s_dmi = if_else(length(dmr[hdm_pa == "Y"]) > 0,
                            mean(dmr[hdm_pa == "Y"]),
                            0),
            nstem_ha_l_hw_wb = sum(phf_site[broom_pa == "Y"]),
            nstem_ha_l_hw_si = sum(phf_site[stem_pa == "Y"])) %>% 
  mutate(p_sim = nstem_ha_l_hw_sim/nstem_ha_l_hw, 
         p_l_hw_inf = nstem_ha_l_hw_inf/nstem_ha_l_hw,
         p_l_hw_wb = nstem_ha_l_hw_wb/nstem_ha_l_hw,
         p_l_hw_si = nstem_ha_l_hw_si/nstem_ha_l_hw) %>% 
  select(-c(nstem_ha_l_hw, nstem_ha_l_hw_sim, nstem_ha_l_hw_inf, 
            nstem_ha_l_hw_wb, nstem_ha_l_hw_si))

#Summarize variables across sites
#For 0-15m
x <- x %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}")) %>%
  pivot_longer(
    cols = where(is.numeric), 
    names_to = c("variable", "metric"),
    names_pattern = "^(.*)_(mean|median|min|max)$",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = metric, 
              values_from = value) %>% 
  mutate(across(where(is.numeric), ~round(.x, 2))) %>% 
  mutate(range = paste0("[", min, "-", max, "]")) %>% 
  select(-c(min, max)) %>% 
  pivot_wider(names_from = variable,
              values_from = c(mean, median, range))

#For 0-50m
x1 <- x1 %>% 
  summarise(across(where(is.numeric), list(
    mean = ~mean(.),
    median = ~median(.),
    min = ~min(.),
    max = ~max(.)
  ), .names = "{.col}_{.fn}")) %>%
  pivot_longer(
    cols = where(is.numeric), 
    names_to = c("variable", "metric"),
    names_pattern = "^(.*)_(mean|median|min|max)$",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = metric, 
              values_from = value) %>% 
  mutate(across(where(is.numeric), ~round(.x, 2))) %>% 
  mutate(range = paste0("[", min, "-", max, "]")) %>% 
  select(-c(min, max)) %>% 
  pivot_wider(names_from = variable,
              values_from = c(mean, median, range))

#Add a columns identifying section and crown class
x <- x %>% 
  mutate(sec = "0_15", 
         crown_class_2 = "all")
x1 <- x1 %>% 
  mutate(sec = "0_50", 
         crown_class_2 = "all")

#Bind this to the working dataframe
reg_i_live <- bind_rows(reg_i_live, x, x1)
```

Good, format and clean up. 
```{r}
names(reg_i_live)
#Reorder columns
reg_i_live <- reg_i_live %>% 
  select(sec, crown_class_2, ends_with("p_sim"), 
         ends_with("p_l_hw_inf"), ends_with("s_dmr"),
         ends_with("s_dmi"), ends_with("p_l_hw_wb"),
         ends_with("p_l_hw_si"))

#Reorder rows
reg_i_live <- reg_i_live %>% 
  mutate(crown_class_2 = as.character(crown_class_2)) %>% 
  mutate(crown_class_2 = if_else(crown_class_2 == "C", 
                                 "D_C", 
                                 crown_class_2)) %>% 
  mutate(sec = factor(sec, levels = c("all", "0_15", "0_50")),
         crown_class_2 = factor(crown_class_2, 
                                levels = c("all", "D_C", "I", "S"))) %>% 
  arrange(sec, crown_class_2)
```

###Distance of spread
Use some summary metrics to capture how far HDM has spread (in live Hw).
  - Infection perimeter = distance from the edge below which 
  90% of the infected live Hw occur. 
    - Its better than using the most distant tree 
    because it uses more than just one datapoint; the exception is when there 
    is just one or two infected trees at a site. In those cases, it will be
    disproportinately determined by those trees.
  - Outer infected tree = infected live Hw most distant from the mature forest
  edge
  
Infection perimeter.
```{r}
#Calcualte at the transect level first
#Used if_else statement because if there are no infected Hw, then infection
#perimeter is 0
#Note: only 32 transects are represented here because one site (ph_3) had 
#no live Hw on one transect
reg.infper_tran <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & spp == "Hw" & status %in% live_stat &
           hdm_pa == "Y") %>% 
  group_by(site_id, plot_id) %>% 
  summarise(infper = if_else(sum(hdm_pa == "Y")>0, 
                                 quantile(dist_y_h[hdm_pa == "Y"], probs = 0.9),
                                 0)) 
range(reg.infper_tran$infper)

#Average across transects to get site level estimate
reg.infper_site <- reg.infper_tran %>% 
  group_by(site_id) %>% 
  summarise(infper_mean = mean(infper), 
            infper_sd = sd(infper)) 

#Take a look
summary(reg.infper_site)
```

Outer infected tree at each site. Don't need to filter out simulated trees
because all simulated Hw are uninfected. 
```{r}
#Start by getting the outer infected tree at each site
reg.out_inf <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & spp == "Hw" & status %in% live_stat &
           hdm_pa == "Y") %>% 
  group_by(site_id) %>% 
  summarise(out_inf_dist = max(dist_y_h)) 

#Take a look at this:
summary(reg.out_inf)
```

###Vertical infection distribution
We also want to summarize how infection is distributed in the tree. E.g. if its
a DMR 1, then we want to know whether the 1 is in the bottom, middle or upper 
crown. Do this for live Hw trees that have a DMR of >=1. The basic 
strategy is going to be to break down each tree level DMR (possible values for 
infected tree of 1-6) by the contributions of each crown third. 
```{r}
#Start by creating subsetting the dataframe to just DMR ratings (for the whole 
#tree and for the crown thirds).
reg.vpos <- regen %>% 
  mutate(resid = if_else(tree_id %in% resid_rm, "Y", "N")) %>% 
  filter(resid == "N" & spp == "Hw" & status %in% live_stat &
           hdm_pa == "Y" & dmr >= 1) %>% 
  select(tree_id, site_id, crown_class, dmr, dmr_l, dmr_m, dmr_u)

#Divide each crown third rating by the total DMR to get the crown third 
#contribution
reg.vpos <- reg.vpos %>% 
  mutate(cont_l = dmr_l/dmr,
         cont_m = dmr_m/dmr,
         cont_u = dmr_u/dmr)

#Lengthen so that crown third contributions are a single column
reg.vpos <- reg.vpos %>% 
  select(-c(dmr_l, dmr_m, dmr_u)) %>% 
  pivot_longer(cols = starts_with("cont"),
               values_to = "cont",
               names_to = "ct",
               names_prefix = "cont_")

#Summarize this for each crown class. This creates groups for every unique
#crown class - dmr -crown third combination. Within each group, it takes each
#row and averages the contribution value for each crown third. 
reg.vpos <- reg.vpos %>% 
  group_by(crown_class, dmr, ct) %>% 
  summarise(cont = mean(cont),
            n_tree = n())
```

Graph this distribution
```{r}
#We will use the n_tree column to label the plot with how many trees there are 
#for each crown class-dmr combination, but right now there are three values for
#every combination because the dataframe is also subset by crown third. We just
#need one
reg.vpos <- reg.vpos %>% 
  mutate(n_tree = if_else(ct == "l", n_tree, NA))

#Make crwon third a factor
reg.vpos <- reg.vpos %>% 
  mutate(ct = case_match(ct, 
                         "l" ~ "lower",
                         "m" ~ "middle",
                         "u" ~ "upper")) %>% 
  mutate(ct = factor(ct, levels = c("upper", "middle", "lower")))

p <- ggplot(reg.vpos, aes(x = dmr, y = cont, fill = ct)) + 
  geom_bar(stat = "identity", position = "stack") + 
  geom_text(aes(label = n_tree), y = 1, vjust = -0.5) +
  facet_wrap(~crown_class) +
  theme_classic() + 
  scale_y_continuous(limits = c(0, 1.1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  scale_fill_manual(values = colors_ct) + 
  theme(legend.background = element_rect(fill = "lightgrey"),
        legend.key = element_rect(fill = "lightgrey", color = NA),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 20),
        strip.text = element_text(size = 16)) + 
  labs(x = "DMR", 
       y = "Mean crown third contribution", 
       fill = "Crown third")

#Export this plot
# pdf(here("./figures/reg_vdist_inf.pdf"), width = 10, height = 8.5)
# p
# dev.off()
```

##Proportion of trees with growth impacts
Growth impacts start to occur at DMR >=3. See what proportion of codominant Hw
at each site are past that threshold. 
```{r}
#Within 15m calculate the number of dominant/codominant live Hw and the 
#proportion of those with DMR>=3
dmr3_15 <- regen_15_l %>% 
  filter(crown_class_2 == "C") %>% 
  group_by(site_id) %>% 
  summarise(n_dc_hw = n(),
            n_dc_hw_dmr3 = sum(dmr >= 3)) %>% 
  mutate(p_dmr3 = n_dc_hw_dmr3/n_dc_hw)

#Same but over 0-50m
dmr3_50 <- regen_50_l %>% 
  filter(crown_class_2 == "C") %>% 
  group_by(site_id) %>% 
  summarise(n_dc_hw = n(),
            n_dc_hw_dmr3 = sum(dmr >= 3)) %>% 
  mutate(p_dmr3 = n_dc_hw_dmr3/n_dc_hw)

#Take a look at these
summary(dmr3_15)
summary(dmr3_50)
```

##Export tables
Save the tables created in this section. 
```{r}
#Table with all of the regen infection stats
# write_csv(reg_i_all, "./tables/reg_inf_hw_all.csv")

#Table with broken down by interval and crown class for thesis
# write_csv(reg_i_live, here("./tables/reg_inf_hw_live.csv"))
```